import os
from os import listdir
from os.path import join, isfile, isdir
#from html.parser import HTMLParser
import json
import gzip 
import statistics
from datetime import datetime, timedelta
import pandas as pd
pd.options.plotting.backend = "plotly"
#from random import random
import matplotlib
import plotly.express as px
import matplotlib.pyplot as plt
import kaleido ## to be able to export

#import numpy as np
import requests
from math import ceil
#import roman
import time 

from co2eq.flight_utils import AirportDB, CityDB, FlightDB, GoClimateDB, CountryDB, Flight, logger, MyClimate
import co2eq.conf

    
class Meeting:

  def __init__( self, name:str, 
                location:dict, 
                attendee_list:str = None, \
                base_output_dir=None, 
                conf=co2eq.conf.Conf().CONF,  \
                airportDB=True, 
                cityDB=True, 
                flightDB=True, 
                goclimateDB=True ):
    """ Meeting class

    Since conf is used to generate some DB (goclimateDB), DB can either
    be provided as object of set to True to indicate these need to be generated.

    Args:
      name (str): the name of the meeting
      location (dict): a location structure where the meeting is happening
        The dictionnary take sthe foillowing form: 
            {
               "country": "CZ",
               "city": "Prague"
             }
      attendee_list (str or lst): It is expected to be the path of a JSON file 
        that contains the attendee list. By default an attendee is a dictionary 
        structure which at least contains:
           { 
              "country" : "Country Code" 
           } 
        Attendee may also include additional information sur as :
           {
              "country": "KG",
              "organization": "association of communications operators",
              "presence": "on-site"
            },
      base_output_dir (str): the directory where all data and figures are put.
      conf (dict): configuration parameters
      airportDB: the airportDB object ( AirportDB ) or True to indicate the DB
        is generated by FlightDB.
        By default it is set to True.
      cityDB: the cityDB object ( CityDB ) or True to indicate the DB is
        generated by FlightDB.
        By default it is set to True.
      goclimateDB: the cityDB object ( GoClimateDB ) or True to indicate the DB
        is generated by FlightDB.
        By default it is set to True. Note that this is the only DB that needs
        the configuration parameters.

    """
    self.name = name
    self.conf = conf
    print( f"Computing CO2eq for {self.name}\n" )
    print( f"Configuration:\n {self.conf}" )
    if airportDB is True:
      self.airportDB = AirportDB()
    else:
      self.airportDB = airportDB
    if  cityDB is True:
      self.cityDB = CityDB( conf, airportDB=self.airportDB )
    else:
      self.cityDB = cityDB
    if goclimateDB is True:
      self.goclimateDB=GoClimateDB( conf )
    else:
      self.goclimateDB = goclimateDB
    ## flightDB and designate it by the destination airport
    if flightDB is True:
      flightDB = FlightDB( conf, cityDB=self.cityDB, airportDB=self.airportDB, \
                           goclimateDB=self.goclimateDB)
    self.flightDB = flightDB

    self.countryDB = CountryDB()
    # print( f"meeting iata location: {self.iata_location}" )
    if base_output_dir is None:
      base_output_dir = './output'
    self.output_dir = join( base_output_dir, self.name )

    ## location is a dictionary with keys iata, city, state, country)
    self.location = location
    self.meeting_iata_city = self.cityDB.representative_city( self.location )[ 'iata' ]

    if isdir( self.output_dir ) is False:
      os.makedirs( self.output_dir )
    self.logger = logger( conf, __name__ )

    ## DataFrame
    self.df = pd.read_json( attendee_list )

    ### built variables
    self.total_attendee_nbr = len( self.df )
    ## total_map distance to represent the effectice 
    ## traveled distance between the two end points.
    ## this is different from the flying distance.
    self.total_map_distance = None
    ## self.total_co2eq = { ( mode, cabin, co2eq_method ) : co2eq_value }
    self.total_co2eq = {}
    self.cluster_key_list = list( self.df )
    self.cluster_key_list.extend( ['segment_nbr', 'subregion', 'region' ] )
    self.co2eq_method_list = [ 'myclimate', 'goclimate', 'ukgov' ]

    ## data base of all flight information associated to the 
    ## meeting self.flight_db[ ( mode, cabin ) ] [ country ] = flight
    self.flight_db = {}
##   self.km = None

  
  def get_attendee_flight( self, country, cabin ):
    """ returns the flight associated to the attendee for a specific cabin 

    Args: 
      attendee (dict): a structure representing the attendee
      cabin (str) : an indication of the cabin. While the same 
        plane may carry various class, it will afect the CO2eq,
        price, as well as possibly some cabin class will not be
        available in some journeys. As aresult, we choose to 
        associate the cabin to teh flight.
        Note that co2eq is computed for the various known metrics 

    Returns:
      flight (dict) :  a structure that looks like 
        {
          'origin' : self.origin,
          'destination' : self.destination,
          'departure_date' : self.departure_date,
          'return_date' : self.return_date,
          'cabin' : self.cabin,
          'adults' : self.adults,
          'segment_list' : self.segment_list,
          'price' : self.price,
          'currency' : self.currency,
          'travel_duration' : str( self.travel_duration ),
          'flight_duration' : str( self.flight_duration ),
          'flying_distance' : str( self.flying_distance ),
          'map_distance' : str( self.flying_distance ),
          'co2eq' : { 'myclimate' : co2eq,  
                      'ukgov' :     co2eq, 
                      'goclimate' : co2eq } }

    """
    ## object that corresponds to a no-flight
    NULL_FLIGHT = {
      'origin' : self.meeting_iata_city,
      'destination' : self.meeting_iata_city,
#      'departure_date' : self.departure_date,
#      'return_date' : self.return_date,
      'cabin' : cabin,
      'adults' : 1,
      'segment_list' : [],
      'price' : 0,
      'currency' : 'USD',
      'travel_duration' : str( 0 ),
      'flight_duration' : str( 0 ),
      'flying_distance' : 0,
      'map_distance' : 0,
      'co2eq' : { 'myclimate' : 0,  
                  'ukgov' :     0, 
                  'goclimate' : 0 } }

    ## only the country is considered
    ## the country represents the country 
    ## of origin of the attendee
    loc = { "country" : country}

    attendee_iata_city = self.cityDB.representative_city( loc )[ 'iata' ]
    self.logger.debug( f"  - Flight from {attendee_iata_city} to  {self.meeting_iata_city}" )
    if attendee_iata_city == self.meeting_iata_city :
      return NULL_FLIGHT
    if attendee_iata_city in [ '', None ]:
      self.logger.debug( "Unable to find city for {attendee}" )
    try:
      return self.flightDB.force_select_flight( attendee_iata_city , self.meeting_iata_city  )
    except :
#      if 'country' in attendee.keys() and 'city' not in attendee.keys() and 'state' not in attendee.keys() :
      print( f"\n-----------------------------\n"\
             f"Unable to retrieve flight: FROM: {attendee_iata_city} "\
             f"TO: {self.meeting_iata_city}\n" )
      self.debug_country_info( attendee[ 'country' ] )
      raise ValueError( "unable top retrieve flight")

 
  def get_attendee_flight_obj( self, country,  cabin, mode ):
    """ returns the flight object used to compute co2eq and distance 

    This function primary set a speudoi flight in a distance mode 
    which corresponds to a direct flight.
    """

    ## 'distance' mode requires a specific computation 
    if mode == 'distance' :
      loc = { "country" : country}
      attendee_iata_city = self.cityDB.representative_city( loc )[ 'iata' ]
      # meeting_iata_city = self.cityDB.representative_city( self.location )[ 'iata' ]
      self.logger.debug( f"  - Flight from {attendee_iata_city} to  {self.meeting_iata_city}" )
      segment_list = [ [ attendee_iata_city , self.meeting_iata_city  ],  \
                       [ attendee_iata_city , self.meeting_iata_city  ] ]
      flight = { 'segment_list' : [ [ attendee_iata_city , self.meeting_iata_city  ],  \
                                    [ attendee_iata_city , self.meeting_iata_city  ] ], 
                 'cabin' : cabin, 
                 'co2eq' : None } ## forcing co2eq computation
    else: 
      flight = self.get_attendee_flight( country, cabin )
    ## forcing co2eq computation  
    flight = Flight( **flight, cityDB=self.cityDB, \
                     airportDB=self.airportDB, goclimateDB=self.goclimateDB)
    flight = flight.export()
    return flight
      
 
  def build_flight_db( self, mode, cabin ):
    """ compute and retrieve the flight object for mode and cabin

    One the flight objects are prefetched is to prevent repeating the 
    requests to the larger FlightDB.
    Repeated request occurs when diferent co2eq methods are performed 
    as well as when multiple users are coming from the same country
    """
    if ( mode, cabin ) in self.flight_db.keys():
      return None
    self.flight_db[ ( mode, cabin ) ] = {}    
    country_list = self.df[ 'country' ].unique().tolist()
    t_start = time.time()
    for country in country_list :
      flight = self.get_attendee_flight_obj( country,  cabin, mode ) 
      if not isinstance( flight, dict ): 
        raise ValueError( f"unexpected flight object for "\
                f"{( country,  cabin, mode )}: {flight}" )
      self.flight_db[ ( mode, cabin ) ] [ country ] = flight
    t_stop = time.time()
    print( f"Building flight_db in {t_stop - t_start}" )
    print( f"resolution time: {( t_stop - t_start ) / len( country_list ) }")
      
  def get_attendee_co2eq( self, mode, cabin, country, co2eq_method ):
    return self.flight_db[ ( mode, cabin ) ][ country ][ 'co2eq'][ co2eq_method ]
    
  def get_attendee_seg_nbr( self, mode, cabin, country ):
    if mode == 'attendee' :
      mode = 'flight'
    return len( self.flight_db[ ( mode, cabin ) ][ country ][ 'segment_list' ] )
#    return len( self.flight_db[ mode ][ cabin ][ country ][ 'segment_list' ] )

  def get_attendee_subregion( self, country ):
    return self.countryDB.get_country_info( country ).subregion()

  def get_attendee_region( self, country ):
    return self.countryDB.get_country_info( country ).region()

  def get_attendee_map_distance( self, mode, cabin, country ):
    """
    
    We provide mode and cabin to make sure the corresponding flight have 
    "previously" been computed, but the distance does not depends on mode
    and cabin.
    """
    return self.flight_db[ ( mode, cabin ) ][ country ][ 'map_distance' ]


  def kwargs_to_str( self, **kwargs:dict ) -> str:
    """ build a file name string from kwargs """
    file_name = ""
    for key, value in kwargs.items():
      file_name += f"{key}-{value}--"
    return file_name[ :-1 ] 

  def str_to_kwargs( self, file_name ): 
    """ retrieves kwargs from a file name 

    This is the reverse function of kwargs_to_file_name. 

    Args:
      file_name (str): the file name

    Returns:
      arg_dict (dict): the various characteristics of the file
        { 'mode' : mode,
          'cluster_key' : cluster_key,
          'co2eq' : co2eq,
          'cabin' : cabin }
    """
    
    if file_name[ -4: ] in [ '.svg', '.json' ] :
      file_name = file_name[: -4 ]   
    kw = {}  
    for seg in file_name.split('--'):
      split_seg = seg.split( '-' )
      kw[ split_seg[ 0 ] ] = split_seg[ 1 ]
    return kw

  def json_file_name( self, mode, cluster_key, co2eq_method=None, cabin=None ):
    if mode == 'attendee' and co2eq_method is None and cabin is None :
      data_file = self.kwargs_to_str( mode=mode, cluster_key=cluster_key )
    else: 
      data_file = self.kwargs_to_str( mode=mode, cluster_key=cluster_key,\
        co2eq_method=co2eq_method, cabin=cabin)
    return os.path.join( self.output_dir, data_file + ".json")

  def image_file_name( self, ext, mode, cabin, cluster_key=None ):
    if mode == 'attendee' and cluster_key is None :
      data_file = self.kwargs_to_str( mode=mode, cabin=cabin )
    elif mode in [ 'flight', 'distance' ]: 
      data_file = self.kwargs_to_str( mode=mode, cluster_key=cluster_key,\
              cabin=cabin )
    return os.path.join( self.output_dir, data_file + "." + ext )



  def build_data( self, mode='flight', cluster_key='country', co2eq_method='myclimate', cabin='AVERAGE' ) -> dict :
    """ co2 equivalent based on real flights including multiple segments)

    The possible modes are 'attendee', 'flight', 'distance'. 
    'flight' and 'distance' always output a number of CO2eq in kg
    'attendee' always outputs a number of attendees
    cluster_key can be any key mention in the participant object or 
    take special values like 'segmentNbr'.

    Todo:
      * we are doing now a lot of measurements and each time we retrieves
        the flights. We need to be able to comput ea attendee_flight_list once. 
    """

    ## read from json if already computed
    data_file = self.json_file_name( mode, cluster_key, \
            co2eq_method=co2eq_method, cabin=cabin )   
    if data_file is True: 
      return pd.read_json( data_file )

    ## 1. preparing flights information
    if mode in [ 'flight', 'distance' ] :
      self.build_flight_db( mode, cabin )
    elif mode == 'attendee' and cluster_key == 'segment_nbr':
      self.build_flight_db( 'flight', cabin )
    
    ## 2.a. preparing attende based values based on cluster values cluster_key and mode
    if cluster_key == 'segment_nbr' :
      self.df[ 'segment_nbr' ] = self.df.apply( lambda x: self.get_attendee_seg_nbr( mode, cabin, x['country'] ), axis=1)
    elif cluster_key == 'subregion' :
      self.df[ 'subregion' ] = self.df.apply( lambda x: self.get_attendee_subregion( x['country'] ), axis=1 )
    elif cluster_key == 'region' :
      self.df[ 'region' ] = self.df.apply( lambda x: self.get_attendee_subregion( x['country'] ), axis=1 )
    
    ## 2.b computing co2eq / distance based on mode 
    if mode in [ 'flight', 'distance' ]:
      self.df[ co2eq_method ] = self.df.apply( lambda x: self.get_attendee_co2eq( mode, cabin, x['country'], co2eq_method) , axis=1)
      ## computing total_co2eq
      k = ( mode, cabin, co2eq_method )
      if k not in self.total_co2eq.keys() :
        self.total_co2eq[ k ]  = self.df[ co2eq_method ].sum()
      ## we ensure totalk_map_distance is computed.
      if self.total_map_distance is None:
        self.df[ "map_distance" ] = self.df.apply( lambda x: self.get_attendee_map_distance( mode, cabin, x[ 'country' ] ) , axis=1)
        self.total_map_distance = self.df[ "map_distance" ].sum()

    ## 3. extracting the data to be plot        
    if mode == 'attendee':
      ## group by country, take the 'country' colum  and count elements
      df = self.df.groupby( by=[ cluster_key ], sort=False )[ cluster_key ].count()
    elif mode in [ 'flight', 'distance' ]:
      df = self.df.groupby( by=[ cluster_key ], sort=False )[ co2eq_method ].sum()
#      df = self.df.groupby( by=[ f"co2eq-{co2eq_method}", cluster_key ], sort=False ).sum().unstack()

    df.to_json( data_file )
    return df
    
###plot:
###    basic stacked histogram:
###        https://plotly.com/python/bar-charts/#bar-chart-with-hover-text
###    interactive versus html
###        https://plotly.com/python/interactive-html-export/#interactive-vs-static-export
###        https://plotly.com/python/static-image-export/
###    Dropdown Menus in Python (to consider modes, cluster_key, co2eq method)
###        https://plotly.com/python/dropdowns/

### using the backend 
### https://plotly.com/python/pandas-backend/
### https://www.shanelynn.ie/bar-plots-in-python-using-pandas-dataframes/


  def plot_co2eq( self, mode, cluster_key, cabin ):
  ## https://plotly.com/python/wide-form/

    col_cluster_key = []  ## legend
    col_co2eq_method = [] ## column title
    col_co2eq = []      ## y values
    
    for co2eq_method in self.co2eq_method_list :
      d = self.build_data( mode=mode, cluster_key=cluster_key,\
              co2eq_method=co2eq_method, cabin=cabin )
      col_cluster_key.extend( d.index.values )
      col_co2eq_method.extend(  [ d.name for i in d.index.values ] )
      col_co2eq.extend( d.to_list() )
    df = pd.DataFrame( { d.index.name : col_cluster_key, 
                            'co2eq_method' : col_co2eq_method, 
                            'co2eq' : col_co2eq } )
    ## title
    print( f"self.total_co2eq: {self.total_co2eq}" )
    co2eq_list = [ self.total_co2eq[ ( mode, cabin, m ) ]  for m in self.co2eq_method_list ]
    av = statistics.mean( co2eq_list )
    m = min ( co2eq_list)
    M = max( co2eq_list )
    d_co2eq = ( M - m ) / av * 100.0
    epppkm = av / self.total_map_distance / self.total_attendee_nbr 
    title = f"{self.name} CO2eq emissions per {cluster_key} in  mode {mode}, cabin {cabin}<br>"\
            f"   - Co2eq:  ~ {self.kg( av )},  min: {self.kg( m )}, max: {self.kg( M )}, D: {d_co2eq:.2f}%<br>"\
            f"   - Co2eq per passenger Km: {self.kg( epppkm )}/p/km <br>"\
            f"   - Attendees: {self.total_attendee_nbr}"

    fig = px.bar(df, x=col_co2eq_method, y="co2eq", color=d.index.name,\
            text=d.index.name, 
            title=title,  
            labels={"co2eq": "CO2eq (Kg)", "x": "CO2eq Estimation Method" } )
    fig.update_layout(font_family="Rockwell", showlegend=True)
    fig.write_html( self.image_file_name( 'html', mode, cabin, cluster_key=cluster_key ) )
    fig.write_image( self.image_file_name( 'svg', mode, cabin, cluster_key=cluster_key ) )    
    fig.show()

  def kg( self, number) :
    """ returns the string associated to number in Kg

    Because Kg is the unit but we want Mg instead of kKg we convert in g 
    """
    #from matplotlib.ticker import EngFormatter
    engFormat = matplotlib.ticker.EngFormatter(unit='g',places=2,sep='')
    return engFormat( 1000 * number )

  def plot_attendees( self, cabin='AVERAGE' ):      
    data = []
    for cluster_key in self.cluster_key_list :
      data.append( self.build_data( mode='attendee', cluster_key=cluster_key, cabin=cabin ) )
    df = pd.DataFrame( data, index=self.cluster_key_list )   
    print( df )  
##    fig = df.plot( kind='bar', subplots=True, ylabel=ylabel, title=title )
##    fig = df.plot( kind='bar', ylabel=ylabel, title=title )
    title = f"Attendees distribution for {self.name} {self.total_attendee_nbr} attendees"
    ylabel =  "Number of attendees" 
#    
    fig = df.plot.bar( title=title )
#    fig.title( title )
#    plt.ylabel( ylabel )

#   
    fig.write_html( self.image_file_name( 'html', 'attendee', cabin ) )
    fig.write_image( self.image_file_name( 'svg', 'attendee', cabin ) )    
    fig.show()
    
 
  def plot( self, mode_list=[ 'attendee', 'flight'], cabine_list=[ 'AVERAGE' ] ):

    ## does not really makes sense 
    self.plot_attendees( 'AVERAGE' ) 

    for mode in mode_list: 
       for cluster_key in self.cluster_key_list :
         for cabin in cabine_list :  
           self.plot_co2eq( mode, cluster_key, cabin )
     
#        index.append( co2eq_method )         
#    plot_data = pd.DataFrame( [ df_pres1, df_pres2], index=[ "df_pres1", "df_pres2" ] ) 
#    plot = pd.DataFrame( [ df_pres1, df_pres2] )
#    f = plot_data.plot.bar()    
#    f.show()
