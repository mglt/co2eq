import os
from os import listdir
from os.path import join, isfile, isdir
import json
import gzip 
import statistics
from datetime import datetime, timedelta
import pandas as pd
pd.options.plotting.backend = "plotly"
import matplotlib
import plotly.express as px
import matplotlib.pyplot as plt
import kaleido ## to be able to export
import roman 

import requests
from math import ceil
import time 

from co2eq.flight_utils import AirportDB, CityDB, FlightDB, GoClimateDB, CountryDB, Flight, logger, MyClimate
import co2eq.conf
import co2eq.fig
import co2eq.md

class Meeting:

  def __init__( self, name:str, 
                location:dict, 
                conf=co2eq.conf.Conf().CONF,  \
                attendee_list:str = None, \
                base_output_dir=None, 
                airportDB=True, 
                cityDB=True, 
                flightDB=True, 
                goclimateDB=True ):
    """ Meeting class

    Since conf is used to generate some DB (goclimateDB), DB can either
    be provided as object of set to True to indicate these need to be generated.

    Args:
      name (str): the name of the meeting
      location (dict): a location structure where the meeting is happening
        The dictionnary take sthe foillowing form: 
            {
               "country": "CZ",
               "city": "Prague"
             }
      attendee_list (str or lst): It is expected to be the path of a JSON file 
        that contains the attendee list. By default an attendee is a dictionary 
        structure which at least contains:
           { 
              "country" : "Country Code" 
           } 
        Attendee may also include additional information sur as :
           {
              "country": "KG",
              "organization": "association of communications operators",
              "presence": "on-site"
            },
      base_output_dir (str): the directory where all data and figures are put.
      conf (dict): configuration parameters
      airportDB: the airportDB object ( AirportDB ) or True to indicate the DB
        is generated by FlightDB.
        By default it is set to True.
      cityDB: the cityDB object ( CityDB ) or True to indicate the DB is
        generated by FlightDB.
        By default it is set to True.
      goclimateDB: the cityDB object ( GoClimateDB ) or True to indicate the DB
        is generated by FlightDB.
        By default it is set to True. Note that this is the only DB that needs
        the configuration parameters.

    """
    self.name = name
    self.conf = conf
    print( f"Computing CO2eq for {self.name}\n" )
    print( f"Configuration:\n {self.conf}" )
    self.init_DB( airportDB, cityDB, flightDB, goclimateDB )
    self.init_output_dir( base_output_dir )
    # print( f"meeting iata location: {self.iata_location}" )
    self.logger = logger( conf, __name__ )

    ## location is a dictionary with keys iata, city, state, country)
    self.location = location
    self.meeting_iata_city = self.cityDB.representative_city( self.location )[ 'iata' ]

    self.attendee_list = attendee_list
    df = pd.read_json( attendee_list )
    ## to build flightDB
    self.country_list = df[ 'country' ].unique().tolist()
 #   self.total_attendee_nbr = len( df )
    self.init_cluster_key_list( df )
    self.co2eq_method_list = [ 'myclimate', 'goclimate', 'ukgov' ]

    ## DataFrame
    self.df_data = {}
    self.info = {}
    ### built variables
    ##    self.total_attendee_nbr = None
    ## total_map distance to represent the effectice 
    ## traveled distance between the two end points.
    ## this is different from the flying distance.
#    self.total_map_distance = None
    ## self.total_co2eq = { ( mode, cabin, co2eq_method ) : co2eq_value }
#    self.total_co2eq = {}
#    self.cluster_key_list = [] # list( self.df_attendee_list )
    # self.cluster_key_list.extend( ['segment_nbr', 'subregion', 'region', 'co2eq' ] )
#    self.co2eq_method_list = [] #[ 'myclimate', 'goclimate', 'ukgov' ]

    ## data base of all flight information associated to the 
    ## meeting self.flight_db[ ( mode, cabin ) ] [ country ] = flight
    self.flight_db = {}
##   self.km = None
    ## size of the figures. one figure is currenlty composed of 
    ## multiple subfigures. The variables are coordinated at the 
    ## Meeting object level as the size must be indicated when 
    ## generating the figure (html and svg format) as well as 
    ## when the figure is included in the md file in an <embed/> 
    ## HTML command
    self.fig_height=600
    self.fig_width=1500

  def init_DB( self, airportDB, cityDB, flightDB, goclimateDB ):
    """ initializes airportDB, cityDB, flightDB, goclimateDB and CountryDB """

    if airportDB is True:
      self.airportDB = AirportDB()
    else:
      self.airportDB = airportDB
    if  cityDB is True:
      self.cityDB = CityDB( self.conf, airportDB=self.airportDB )
    else:
      self.cityDB = cityDB
    if goclimateDB is True:
      self.goclimateDB=GoClimateDB( self.conf )
    else:
      self.goclimateDB = goclimateDB
    ## flightDB and designate it by the destination airport
    if flightDB is True:
      flightDB = FlightDB( self.conf, cityDB=self.cityDB, airportDB=self.airportDB, \
                           goclimateDB=self.goclimateDB)
    self.flightDB = flightDB

    self.countryDB = CountryDB()
 
  def init_output_dir( self, base_output_dir ):
    """initializes teh output directory """
    if base_output_dir is None:
      base_output_dir = './output'
    self.output_dir = join( base_output_dir, self.name )
    if isdir( self.output_dir ) is False:
      os.makedirs( self.output_dir )

  def init_cluster_key_list( self, df ): 
    self.cluster_key_list = list( df )
    if 'country' in self.cluster_key_list:
      self.cluster_key_list.extend( ['segment_nbr', 'subregion', 'region', 'co2eq' ] )
    ## ensure 'presence' is in the first position 
    if 'presence' in self.cluster_key_list:
      self.cluster_key_list.remove( 'presence' )
      self.cluster_key_list.insert( 0, 'presence' )


  def get_attendee_flight( self, country, cabin ):
    """ returns the flight associated to the attendee for a specific cabin 

    Args: 
      attendee (dict): a structure representing the attendee
      cabin (str) : an indication of the cabin. While the same 
        plane may carry various class, it will afect the CO2eq,
        price, as well as possibly some cabin class will not be
        available in some journeys. As aresult, we choose to 
        associate the cabin to teh flight.
        Note that co2eq is computed for the various known metrics 

    Returns:
      flight (dict) :  a structure that looks like 
        {
          'origin' : self.origin,
          'destination' : self.destination,
          'departure_date' : self.departure_date,
          'return_date' : self.return_date,
          'cabin' : self.cabin,
          'adults' : self.adults,
          'segment_list' : self.segment_list,
          'price' : self.price,
          'currency' : self.currency,
          'travel_duration' : str( self.travel_duration ),
          'flight_duration' : str( self.flight_duration ),
          'flying_distance' : str( self.flying_distance ),
          'map_distance' : str( self.flying_distance ),
          'co2eq' : { 'myclimate' : co2eq,  
                      'ukgov' :     co2eq, 
                      'goclimate' : co2eq } }

    """
    ## object that corresponds to a no-flight
    NULL_FLIGHT = {
      'origin' : self.meeting_iata_city,
      'destination' : self.meeting_iata_city,
#      'departure_date' : self.departure_date,
#      'return_date' : self.return_date,
      'cabin' : cabin,
      'adults' : 1,
      'segment_list' : [],
      'price' : 0,
      'currency' : 'USD',
      'travel_duration' : str( 0 ),
      'flight_duration' : str( 0 ),
      'flying_distance' : 0,
      'map_distance' : 0,
      'co2eq' : { 'myclimate' : 0,  
                  'ukgov' :     0, 
                  'goclimate' : 0 } }

    ## only the country is considered
    ## the country represents the country 
    ## of origin of the attendee
    loc = { "country" : country}

    attendee_iata_city = self.cityDB.representative_city( loc )[ 'iata' ]
    self.logger.debug( f"  - Flight from {attendee_iata_city} to  {self.meeting_iata_city}" )
    if attendee_iata_city == self.meeting_iata_city :
      return NULL_FLIGHT
    if attendee_iata_city in [ '', None ]:
      self.logger.debug( "Unable to find city for {attendee}" )
    try:
      return self.flightDB.force_select_flight( attendee_iata_city , self.meeting_iata_city  )
    except :
#      if 'country' in attendee.keys() and 'city' not in attendee.keys() and 'state' not in attendee.keys() :
      print( f"\n-----------------------------\n"\
             f"Unable to retrieve flight: FROM: {attendee_iata_city} "\
             f"TO: {self.meeting_iata_city}\n" )
      self.debug_country_info( attendee[ 'country' ] )
      raise ValueError( "unable top retrieve flight")


  def debug_country_info( self, country ):
    """ provides information to understand why a flight cannot be retrived 

    The ability to retrieve a flight depends on:
      1) the correctness and coherence of the iata_city_codes-2015.json, iata_city_airport_map.json and countryinfo
      2) the ability of Amadeus to retrieve an itinerary
      3) Many other reasons...
    This function helps to find why a flight cannot be retrieved. 
    It is limited to the case where only the country has been provided.
    """
    ## Step 1: checking the capital returned by country info
    country_info = self.cityDB.countryDB.get_country_info( country )
    print( f"-- step 1: Capital of {country_info.name()} ({country}) is "\
           f"{country_info.capital()}\n"\
           f"           coordinates of the capital are {country_info.capital_latlng()}\n"\
           f"           Please check capital and coordinates are correct.\n"\
           f"           If these information are not correct update the\n"\
           f"           countryinfo data.")
 
    ## Step 2: checking the the matching cities from the IATA city code DB
    iata_capital_list = self.cityDB.get_city( country=country, name=country_info.capital() )
    if len( iata_capital_list ) > 0:
      iata_capital = iata_capital_list[ 0 ]
    else:
      iata_capital = None
    print( f"-- step 2: Searching IATA city by matching the capital\n"\
           f"           name returns: the following city {iata_capital}.\n"\
           f"           A response is only expected when there is a match\n"\
           f"           Between names. It may not happen. In case a match is\n"\
           f"           expected, please consider carefully changing the\n"\
           f"           'capital' in the countryinfo data or the 'name'\n"\
           f"           in the iata_city_codes-2015.json file." )
    ## Step 3: checking the city returned by evaluating the distances
    iata_rep_city = self.cityDB.country_representative_city( country )
    print( f"-- step 3: Searching capital via distance returns {iata_rep_city}\n"\
           f"           There cases where the capital has been overwritten \n"\
           f"           by a larger city (see ISO3166_REPRESENTATIVE_CITY).\n"\
           f"           If the result is surprising  here are possible\n"\
           f"           reasons:\n"\
           f"             a) Coordinate of the expected city in the file\n"\
           f"                iata_city_codes-2015.json are not correct.\n"\
           f"                In this case, upadte the coordinates in \n"\
           f"                iata_city_codes-2015.json\n"\
           f"             b) The distance method only considers cities with airports\n"\
           f"                The city in question is not associated to sufficiently\n"\
           f"                large airports. This could be that the IATA city airport\n"\
           f"                In iata_city_codes-2015.json does not corresponds to the\n"\
           f"                IATA city airport of iata_city_airport_map.\n"\
           f"             c) Amadeux is unable to retrieve flights itinerary from that airport" )
 
    coordinates = country_info.capital_latlng()
    capital = { 'latitude' : coordinates[ 0 ], 'longitude' : coordinates[ 1 ] }
    if iata_capital is not None:
      print( f"Distance from {country_info.capital()} of IATA city found by name matching\n"\
             f"(step 2 ) : {self.cityDB.dist( capital, iata_capital )}\n" )
    print( f"Distance from {country_info.capital()} of IATA city found by shortest distance\n"\
           f"(step 3) : {self.cityDB.dist( capital, iata_rep_city )}\n" )
    ## Step3.5 checking airports associated to the IATA 
    if iata_capital is not None:
      print( f"-- step 4: Does the IATA city (matching capital name) has airports ?\n"\
             f"           {self.cityDB.has_airports( iata_capital ) }\n"\
             f"           False may indicate the IATA code of the city is not\n"\
             f"           recognized by the iata_city_airport_map.\n"\
             f"           True may indicate everything is correct but Amadeux is unable\n"\
             f"           to retrieve an itinerary. If that is the case, this may be adjusted\n"\
             f"           by updating ISO3166_REPRESENTATIVE_CITY.\n")

    print( f"Please check the log in {self.conf[ 'log' ]} "\
           f"for further details. You can do tail -f {self.conf[ 'log' ]}.\n\n"\
           f"If you have not detected something abnormal, it may be that AMADEUS "\
           f"was not able to retrieve the flight at this time and that the next "\
           f" attempt will work. Keep finger crossed and retry." )


  def get_attendee_flight_obj( self, country,  cabin, mode ):
    """ returns the flight object used to compute co2eq and distance 

    This function primarily sets a speudo flight in a distance mode 
    which corresponds to a direct flight.
    """

    ## 'distance' mode requires a specific computation 
    if mode == 'distance' :
      loc = { "country" : country}
      attendee_iata_city = self.cityDB.representative_city( loc )[ 'iata' ]
      # meeting_iata_city = self.cityDB.representative_city( self.location )[ 'iata' ]
      self.logger.debug( f"  - Flight from {attendee_iata_city} to  {self.meeting_iata_city}" )
      segment_list = [ [ attendee_iata_city , self.meeting_iata_city  ],  \
                       [ attendee_iata_city , self.meeting_iata_city  ] ]
      flight = { 'segment_list' : [ [ attendee_iata_city , self.meeting_iata_city  ],  \
                                    [ attendee_iata_city , self.meeting_iata_city  ] ], 
                 'cabin' : cabin, 
                 'co2eq' : None } ## forcing co2eq computation
    else: 
      flight = self.get_attendee_flight( country, cabin )
    ## forcing co2eq computation  
    flight = Flight( **flight, cityDB=self.cityDB, \
                     airportDB=self.airportDB, goclimateDB=self.goclimateDB)
    flight = flight.export()
    return flight
      
 
  def build_flight_db( self, mode, cabin ):
    """ compute and retrieve the flight object for mode and cabin

    One the flight objects are prefetched is to prevent repeating the 
    requests to the larger FlightDB.
    Repeated request occurs when diferent co2eq methods are performed 
    as well as when multiple users are coming from the same country

    The database self.db is as represented below:
    { (mode, cabin) :
      { country_code : 
        { 'co2eq_method' : 
          { 'goclimate' : gocliamte_value,
            'myclimate' : myclimate_value,
            'uk_gov' : uk_gov_value }  
          'segment_list' : 3 },
        country_code :     
        { 'co2eq_method' : 
          { 'goclimate' : gocliamte_value,
            ... }
      },
      (mode, cabin) :
      { country_code : 
      ...
      },
    }  
    """
    if ( mode, cabin ) in self.flight_db.keys():
      return None
    self.flight_db[ ( mode, cabin ) ] = {}    
#    country_list = self.df_attendee_list[ 'country' ].unique().tolist()
    t_start = time.time()
    for country in self.country_list :
      flight = self.get_attendee_flight_obj( country,  cabin, mode ) 
      if not isinstance( flight, dict ): 
        raise ValueError( f"unexpected flight object for "\
                f"{( country,  cabin, mode )}: {flight}" )
      self.flight_db[ ( mode, cabin ) ] [ country ] = flight
    t_stop = time.time()
    print( f"Building flight_db in {t_stop - t_start} sec" )
    print( f"resolution time: {( t_stop - t_start ) / len( self.country_list ) } sec")



  ## the following functions are helpers to complete the dataframe
  def get_attendee_co2eq( self, mode, cabin, country, co2eq_method ):
    print( f"country: {country}" )
    print( self.flight_db[ ( mode, cabin ) ][ country ] )
    print( self.flight_db[ ( mode, cabin ) ][ country ][ 'co2eq'] )
    return self.flight_db[ ( mode, cabin ) ][ country ][ 'co2eq'][ co2eq_method ]
    
  def get_attendee_seg_nbr( self, mode, cabin, country ):
    if mode == 'attendee' :
      mode = 'flight'
    return len( self.flight_db[ ( mode, cabin ) ][ country ][ 'segment_list' ] )
#    return len( self.flight_db[ mode ][ cabin ][ country ][ 'segment_list' ] )

  def get_attendee_subregion( self, country ):
    return self.countryDB.get_country_info( country ).subregion()

  def get_attendee_region( self, country ):
    return self.countryDB.get_country_info( country ).region()

  def get_attendee_map_distance( self, mode, cabin, country ):
    """
    
    We provide mode and cabin to make sure the corresponding flight have 
    "previously" been computed, but the distance does not depends on mode
    and cabin.
    """
    return self.flight_db[ ( mode, cabin ) ][ country ][ 'map_distance' ]


  def kwargs_to_str( self, **kwargs:dict ) -> str:
    """ build a file name string from kwargs """
    file_name = ""
    for key, value in kwargs.items():
      file_name += f"{key}-{value}--"
    return file_name[ :-2 ] 

  def str_to_kwargs( self, file_name ): 
    """ retrieves kwargs from a file name 

    This is the reverse function of kwargs_to_file_name. 

    Args:
      file_name (str): the file name

    Returns:
      arg_dict (dict): the various characteristics of the file
        { 'mode' : mode,
          'cluster_key' : cluster_key,
          'co2eq' : co2eq,
          'cabin' : cabin }
    """
    
    if file_name[ -4: ] in [ '.svg', '.json' ] :
      file_name = file_name[: -4 ]   
    kw = {}  
    for seg in file_name.split('--'):
      split_seg = seg.split( '-' )
      kw[ split_seg[ 0 ] ] = split_seg[ 1 ]
    return kw

  def json_file_name( self, name, mode, cluster_key=None, co2eq_method=None, cabin=None ):
    if mode == 'attendee' : 
      if co2eq_method is not None and cabin is not None :
        raise ValueError( f"with mode 'attendee', co2eq_method"\
                f" and cabin MUST be None. Got {locals()}" ) 
    f_kwargs = { } 
##    print( locals() )
    for k in list( locals().keys() ):
      if k in [ 'self', 'ext', 'f_kwargs' ]:
        continue
      if locals()[ k ] is not None:
        f_kwargs[ k] = locals()[ k ]
    data_file = self.kwargs_to_str( **f_kwargs )
    return os.path.join( self.output_dir, data_file + ".json")

# data_file = self.kwargs_to_str( name=name, mode=mode, cluster_key=cluster_key )
#    else: 
#      data_file = self.kwargs_to_str( name=name, mode=mode, cluster_key=cluster_key,\
#        co2eq_method=co2eq_method, cabin=cabin)
#    return os.path.join( self.output_dir, data_file + ".json")

  def image_file_name( self, name, ext, mode, cabin=None, cluster_key=None, co2eq_method=None, on_site=None, no_path=False, most_present=None, most_emitters=None ):
    """ return an image file name
   
    The intent is to ensure a certain format in the file names, as
    well as to perform some minor checks and avoid duplictaed files
    with different names. 
    """
    if mode == 'attendee' and ( cabin is not None or co2eq_method is not None ):
      raise ValueError( f"with mode 'attendee'  cabin and co2eq_method"\
              "are expected to be set to None. Got {locals()}." )
    f_kwargs = { } 
##    print( locals() )
    for k in list( locals().keys() ):
      if k in [ 'self', 'ext', 'f_kwargs', 'no_path' ]:
        continue
      if locals()[ k ] is not None:
        f_kwargs[ k] = locals()[ k ]
    data_file = self.kwargs_to_str( **f_kwargs )
    file_name = data_file + "." + ext
    if no_path is True:
      return file_name
    return os.path.join( self.output_dir, file_name )



  def df_to_co2eq_info( self, df ):
    print( "--- df" )
    print( df.info )
    attendee_nbr  = len( df )
    map_distance = df[ "map_distance" ].sum() 
    co2eq = {}
    for co2eq_method in self.co2eq_method_list :
      co2eq[ co2eq_method ] = df[ co2eq_method ].sum()    
    co2eq_list = co2eq.values()
#    for m in self.co2eq_method_list:
#      co2eq_list.append( self.co2eq[ ( mode, cabin, m ) ] )
    co2eq[ 'average' ] = statistics.mean( co2eq_list )
    co2eq[ 'stdev' ] = statistics.stdev( co2eq_list ) 
    co2eq[ 'min' ]  = min ( co2eq_list)
    co2eq[ 'max' ]  = max( co2eq_list )
#    print( f"total_map_distance : {self.total_map_distance}" )
#    print( f"total_attendee_nbr: {self.total_attendee_nbr}" )
    print( f"co2eq[ 'average' ]: {co2eq[ 'average' ]} [{type(co2eq[ 'average' ])}]" ) 
    print( f"map_distance: {map_distance} [{type(map_distance)}]" ) 
    print( f"attendee_nbr: {attendee_nbr} [{type(attendee_nbr)}]" ) 
    if attendee_nbr == 0:
      co2eq[ 'epppkm' ] = None
    else: 
      co2eq[ 'epppkm' ] = co2eq[ 'average' ] / map_distance / attendee_nbr
#    title = f"{self.name} Distribution of CO2eq emissions for {mode} mode, cabin {cabin} "\
#            f"- {self.info[ 'total_attendee_nbr' ]} attendees<br>"\
#            f"   - Co2eq -- mean: {self.kg( self.info[ 'total_co2eq' ][ 'average' ] )}, "\
#            f"min: {self.kg( self.info[ 'totalm )}, max: {self.kg( M )}, std: {self.kg( stdev )}<br>"\
#            f"   - Co2eq per passenger Km: {self.kg( epppkm )}/p/km <br>"\
    return { 'map_distance' : map_distance, 
             'attendee_nbr' : attendee_nbr,
             'co2eq' : co2eq }



  def build_data( self, mode='flight', cabin=None ) -> dict :
    """ co2 equivalent based on real flights including multiple segments)

    The possible modes are 'attendee', 'flight', 'distance'. 
    'flight' and 'distance' always output a number of CO2eq in kg
    'attendee' always outputs a number of attendees
    cluster_key can be any key mention in the participant object or 
    take special values like 'segmentNbr'.

    Todo:
      * we are doing now a lot of measurements and each time we retrieves
        the flights. We need to be able to comput ea attendee_flight_list once. 
    """
    ## return the df in cache is present
    if ( mode, cabin )  in self.df_data.keys():
      return self.df_data[ ( mode, cabin ) ]

    ## read from json if already computed
    ## commenting to force the generation of the pd
    if mode == 'attendee':
      data_file = self.json_file_name( 'data', mode )
      cluster_key_list = self.cluster_key_list[:]
      cluster_key_list.remove( 'co2eq' )
      cabin = None 
    else: 
      if cabin is None: 
        cabin = 'AVERAGE'
      data_file = self.json_file_name( 'data', mode, cabin=cabin ) 

    if data_file is True: 
      self.df_data[ ( mode, cabin ) ] =  pd.read_json( data_file )
      return self.df_data[ ( mode, cabin ) ]

    ## building the data 
    df = pd.read_json( self.attendee_list )

    ## 1. preparing flights information
    if mode in [ 'flight', 'distance' ] :
      self.build_flight_db( mode, cabin )
    elif mode == 'attendee' : # needed for 'segment_nbr'
      self.build_flight_db( 'flight', 'AVERAGE' )
    
    ## 2.a. Filling all values associated to cluster_key 
    for cluster_key in self.cluster_key_list :
      if cluster_key == 'segment_nbr' :
        if mode == 'attendee' :
          ## to compute segment numbers, we use the cabin set to AVERAGE   
          df[ 'segment_nbr' ] = df.apply( lambda x: self.get_attendee_seg_nbr( mode, 'AVERAGE', x['country'] ), axis=1)
        else: 
          df[ 'segment_nbr' ] = df.apply( lambda x: self.get_attendee_seg_nbr( mode, cabin, x['country'] ), axis=1)

      elif cluster_key == 'subregion' :
        df[ 'subregion' ] = df.apply( lambda x: self.get_attendee_subregion( x['country'] ), axis=1 )
      elif cluster_key == 'region' :
        df[ 'region' ] = df.apply( lambda x: self.get_attendee_region( x['country'] ), axis=1 )
      elif cluster_key == 'co2eq' : 
        if mode not in [ 'flight', 'distance' ] or self.co2eq_method_list == []:
          continue
        for co2eq_method in self.co2eq_method_list: 
          df[ co2eq_method ] = df.apply( lambda x: self.get_attendee_co2eq( mode, cabin, x['country'], co2eq_method) , axis=1)
#          ## computing total_co2eq
#          k = ( mode, cabin, co2eq_method )
#          if k not in self.total_co2eq.keys() :
#            self.total_co2eq[ k ]  = df[ co2eq_method ].sum()
        ## we ensure total_map_distance is computed.
        if 'total_map_distance' not in self.info.keys() :
          df[ "map_distance" ] = df.apply( lambda x: self.get_attendee_map_distance( mode, cabin, x[ 'country' ] ) , axis=1)
#          self.total_map_distance = df[ "map_distance" ].sum()

    df.to_json( data_file )
    self.df_data[ ( mode, cabin ) ] =  df
    
    ## building information
##    map_distance = df[ "map_distance" ].sum() 
##    attendee_nbr  = len( df )
##    total_co2eq = {}
##    for m in self.co2eq_method_list :
##      total_co2eq[ co2eq_method ] = df[ co2eq_method ].sum()    
##    total_co2eq_list = total_co2eq.values()
###    for m in self.co2eq_method_list:
###      co2eq_list.append( self.total_co2eq[ ( mode, cabin, m ) ] )
##    total_co2eq[ 'average' ] = statistics.mean( total_co2eq_list )
##    total_co2eq[ 'stdev' ] = statistics.stdev( total_co2eq_list ) 
##    total_co2eq[ 'min' ]  = min ( total_co2eq_list)
##    total_co2eq[ 'max' ]  = max( total_co2eq_list )
###    print( f"total_map_distance : {self.total_map_distance}" )
###    print( f"total_attendee_nbr: {self.total_attendee_nbr}" )
##    total_co2eq[ 'epppkm' ] = total_co2eq[ 'average' ] / self.info[ 'total_map_distance' ] / self.info[ 'total_attendee_nbr' ] 
###    title = f"{self.name} Distribution of CO2eq emissions for {mode} mode, cabin {cabin} "\
###            f"- {self.info[ 'total_attendee_nbr' ]} attendees<br>"\
###            f"   - Co2eq -- mean: {self.kg( self.info[ 'total_co2eq' ][ 'average' ] )}, "\
###            f"min: {self.kg( self.info[ 'totalm )}, max: {self.kg( M )}, std: {self.kg( stdev )}<br>"\
###            f"   - Co2eq per passenger Km: {self.kg( epppkm )}/p/km <br>"\
##    self.info[ ( mode, cabin ) ] = { 'total' : { 'map_distance' : map_distance, 
##                                                 'attendee_nbr' : attendee_nbr,
##                                                 'co2eq' : total_co2eq }
    if mode in [ 'flight', 'distance' ]:
      self.info[ ( mode, cabin ) ] = { 'total' : self.df_to_co2eq_info( df ) } 
      if 'presence' in self.cluster_key_list :
        self.info[ ( mode, cabin ) ][ 'on_site' ] = self.df_to_co2eq_info( df[ df.presence == 'on-site' ] )
##        self.info[ ( mode, cabin ) ][ 'non_on_site' ] = self.df_to_co2eq_info( df[ df.presence != 'on-site' ] )
        self.info[ ( mode, cabin ) ][ 'remote' ] = self.df_to_co2eq_info( df[ df.presence == 'remote' ] )

    return df


##    ## Extraction of the data should be performed in each function.  
##    ## 3. extracting the data to be plot        
##    if mode == 'attendee':
##      ## group by country, take the 'country' colum  and count elements
##      df = self.df_attendee_list.groupby( by=[ cluster_key ], sort=False )[ cluster_key ].count()
##    elif mode in [ 'flight', 'distance' ]:
##      df = self.df_attendee_list.groupby( by=[ cluster_key ], sort=False )[ co2eq_method ].sum()
###      df = self.df_attendee_list.groupby( by=[ f"co2eq-{co2eq_method}", cluster_key ], sort=False ).sum().unstack()
##
##    df.to_json( data_file )
##    return df
    
###plot:
###    basic stacked histogram:
###        https://plotly.com/python/bar-charts/#bar-chart-with-hover-text
###    interactive versus html
###        https://plotly.com/python/interactive-html-export/#interactive-vs-static-export
###        https://plotly.com/python/static-image-export/
###    Dropdown Menus in Python (to consider modes, cluster_key, co2eq method)
###        https://plotly.com/python/dropdowns/

### using the backend 
### https://plotly.com/python/pandas-backend/
### https://www.shanelynn.ie/bar-plots-in-python-using-pandas-dataframes/

  

  def plot_co2eq_distribution( self, mode, cabin, on_site=None, show=False, print_grid=False):
    """ plots the distribution of CO2eq according to cluster_key

    CO2eq distribution is plot against each cluster_key (presence,
    country, subregion, region, ...). 

    Args:
      - on_site: defines whether the distribution concerns 
        attenedess that are 'on-site' (on_site set to True) 
        or ('remote' and 'not-arrived') (on_site set to False) or
        all attendees without any distinctions (on_site set to 
        None). By default, on_site is set to None. Its value 
        only makes sense when 'presence' is specified in df. 
        When on_site is not set to None and 'presence' does 
        not appear as a criteria, the function raises an error.
        and does not generates any graph. We coudl have ignored
        on_site and set it to None, but we want to avoid that a 
        given draft is generated multiple times.  
    
    When 'presence' is provided as a cluster_key two kinds of
    graphs are generated:
      - 1. a CO2eq distribution for EFFECTIVE CO2 emissions that
        is associated to participants that are 'on-ste'
      - 2. a CO2eq distribution for participants that are not 
        'on-site'. This represents a sort of OFFSET.
    
    Note that for both 1. and 2. the CO2eq distribution between 
    'on-site' and 'remote' participant is provided.

    """

    df = self.build_data( mode=mode, cabin=cabin )

    
    ## on_site is only considered when 'presence' is indicated. 
    ## we coudl have set on_site to None, but this might result
    ## in the same graph being re-computed 3 times
    ## (on_site = True/False, None). So we prefer not computing 
    ## the graph when incoherent parameters are provided. 
    if on_site not in [ True, False, None ]:
      raise ValueError( f"Unknown value {on_site} for on_site.\
        Expecting True, False or None" ) 


    if 'presence' not in df.columns and on_site is not None:
      raise ValueError( f"on_site is specified to {on_site} but "\
        f"'presence' is not specified in the data frame.\n"\
        f"{df.info}\ndf.columns: {df.columns}" )

    ## check 'co2eq is a cluster_key and if so handle it properly, 
    ## that is considering all other cluster_keys.
    cluster_key_list = self.cluster_key_list[ : ]
    cluster_key_list.remove( 'co2eq' )
    
    ## https://plotly.com/python/wide-form/
    ## https://keytodatascience.com/groupby-pandas-python
    subfig_list = []

    ## defining how aggregation is performed. In our case
    ## aggregation is performed simultaneously for every 
    ## co2eq_methods
    agg_dict = {}
    for co2eq_method in self.co2eq_method_list :
      agg_dict[ co2eq_method ] = 'sum'

    for cluster_key in cluster_key_list :
      ## with cluster_key set to presence, we plot the CO2eq 
      ## associated to the presence, which includes remote,
      ## not arrived and on-site. 
      ## This is a special case, so we can position each sub
      ## distribution to the more global picture.  
      if cluster_key in [ 'presence' ] :
        sub_df = df.groupby( by=[ cluster_key, ], sort=False ).agg( agg_dict ).reset_index().sort_values( by='myclimate', ascending=False )
      ## for other cluster_key we only focus on the CO2 associated to 
      ## on-site participants'
      else:
        if on_site is True:   
          sub_df = df[ df.presence == 'on-site' ].groupby( by=[ cluster_key, ], sort=False ).agg( agg_dict ).reset_index().sort_values( by='myclimate', ascending=False )
        elif on_site is False:
          sub_df = df[ df.presence != 'on-site' ].groupby( by=[ cluster_key, ], sort=False ).agg( agg_dict ).reset_index().sort_values( by='myclimate', ascending=False )
        elif on_site is None:
          sub_df = df.groupby( by=[ cluster_key, ], sort=False ).agg( agg_dict ).reset_index().sort_values(by='myclimate', ascending=False )
      sub_df = sub_df.set_index( cluster_key ).transpose()
      print( f"sub_df :{sub_df}" )  
      subfig = px.bar(sub_df, x=sub_df.index,  y=sub_df.columns, 
              ##color=d.index.name,\
              # text=d.index.name, 
              title=f"{cluster_key}", 
              ## labels are displayed when mouse is hand over the value.
              labels={ 'value': "CO2eq (Kg)", 'index': "Estimation Method" },
            )
##      print( f"subfig: {subfig}" )
##      raise ValueError
      subfig_list.append( subfig )


    suffix = 'distribution'
    if on_site is True:
      title = f"CO2eq Distribution for On-Site Participants (Effective CO2eq)"
    elif on_site is False:
      title = f"CO2eq Distribution for Remote Participants (~Offset CO2eq)"
    elif on_site is None:
      title = "CO2eq Distribution for ALL Participants (On-Site and Remote)" 
    html_file_name = self.image_file_name( suffix, 'html', mode, cabin=cabin, on_site=on_site )
    svg_file_name=self.image_file_name( suffix, 'svg', mode, cabin=cabin, on_site=on_site )

    fig = co2eq.fig.OneRowSubfig( \
      subfig_list, 
#      offset=1.32, 
#      subfig_title_list=cluster_key_list,
      fig_height=self.fig_height,
      fig_width=self.fig_width,
      fig_title=title,
      print_grid=print_grid,
      show=show,
      shared_xaxes=False,
      shared_yaxes=False,
      legend_offset=[ -0.075, -0.15, -0.225, -0.3, -0.375, -0.45 ],
      horizontal_spacing=0.15,
      html_file_name=html_file_name, 
      svg_file_name=svg_file_name )
#    fig.fig.show()

  def kg( self, number) :
    """ returns the string associated to number in Kg

    Because Kg is the unit but we want Mg instead of kKg we convert in g 
    """
    try: 
      engFormat = matplotlib.ticker.EngFormatter(unit='g',places=2,sep=' ')
      return engFormat( 1000 * number )
    except :
      self.logger.debug( f"  - unable to convert {number} with engFormat - {type(number)}" )
      return None

  def plot_attendee_distribution( self, on_site=None, show=False, print_grid=False ):
    """ 
    args:
      on_site: defines the subset of the attendees. None True False
    """

    df = self.build_data( mode='attendee' )

    ## on_site is only considered when 'presence' is indicated. 
    ## we coudl have set on_site to None, but this might result
    ## in the same graph being re-computed 3 times
    ## (on_site = True/False, None). So we prefer not computing 
    ## the graph when incoherent parameters are provided. 
    if on_site not in [ True, False, None ]:
      raise ValueError( f"Unknown value {on_site} for on_site.\
        Expecting True, False or None" ) 


    if 'presence' not in df.columns and on_site is not None:
      raise ValueError( f"on_site is specified to {on_site} but "\
        f"'presence' is not specified in the data frame.\n"\
        f"{df.info}\ndf.columns: {df.columns}" )

    ## check 'co2eq is a cluster_key and if so handle it properly, 
    ## that is considering all other cluster_keys.
    cluster_key_list = self.cluster_key_list[ : ]
    cluster_key_list.remove( 'co2eq' )
    
    ## https://plotly.com/python/wide-form/
    ## https://keytodatascience.com/groupby-pandas-python
    subfig_list = []

#    ## defining how aggregation is performed. In our case
#    ## aggregation is performed simultaneously for every 
#    ## co2eq_methods
#    agg_dict = {}
#    for co2eq_method in self.co2eq_method_list :
#      agg_dict[ co2eq_method ] = 'sum'

    for cluster_key in cluster_key_list :
      ## with cluster_key set to presence, we plot the number
      ## of attendees. 
      ## associated to the presence, which includes remote,
      ## not arrived and on-site
      if cluster_key in [ 'presence' ] :
#        print( f"------------------------- initial state {cluster_key} / {on_site}" )
#        print( f"--- df: {df.info()}" )
#        print( f"--- df: {df.head()}" )
#        print( f"--- df: {df[[ cluster_key ]].info()}" )
#        print( f"--- df: {df[[ cluster_key ]].head()}" )
        ##sub_df = df.groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index()
        ##sub_serie = df.groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index( name='count' ).sort_values(by='count', ascending=False )
        sub_df = df.groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index( name='count' ).sort_values(by='count', ascending=False )
      ## for other cluster_key we only focus on the CO2 associated to 
      ## on-site participants'
      else:
#        print( f"------------------------- initial state {cluster_key} / {on_site}" )
#        print( f"--- sub_df: {sub_df.info()}" )
#        print( f"--- sub_df: {sub_df.head()}" )
        if on_site is True:   
          ##sub_df = df[ df.presence == 'on-site' ].groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index()
## REDO          sub_serie = df[ df.presence == 'on-site' ].groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count()
          sub_df = df[ df.presence == 'on-site' ].groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index( name='count' ).sort_values(by='count', ascending=False )
        elif on_site is False:
          ##sub_df = df[ df.presence != 'on-site' ].groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index()
##          sub_serie = df[ df.presence != 'on-site' ].groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count()
##          sub_serie = df[ df.presence == 'remote' ].groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count()
          sub_df = df[ df.presence != 'on-site' ].groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index( name='count' ).sort_values(by='count', ascending=False )
        elif on_site is None:
          ##sub_df = df.groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index()
##REDO          sub_serie = df.groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count()
          sub_df = df.groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index( name='count' ).sort_values(by='count', ascending=False )
        else:
          raise ValueError( f"unexpected value for on_site: {on_site}"\
                  f" on_site MUST be in True, False or None." )
######### REDO
##      sub_df = pd.DataFrame( [ sub_serie ] )
##      sub_df.columns.name = cluster_key  


## END REDO
      ##.sort_values(by=, ascending=False )
##      sub_df = df.groupby( by=[ cluster_key, ], sort=False )[ cluster_key ].count().reset_index(
#      print( f"------------------------- grouping {cluster_key} / {on_site} " )
#      print( f"--- sub_df: {sub_df.info()}" )
      sub_df.insert( 0, 'meeting', f"{self.name} - {self.meeting_iata_city}"  )

      print( f"--- sub_df: {sub_df}" )
##      raise ValueError
#      print( f"------------------------- translate {cluster_key} / {on_site}" )
#      sub_df = sub_df[ cluster_key].transpose().reset_index()
      print( f"--- sub_df info: {sub_df.info()}" )
      print( f"--- sub_df head: {sub_df.head()}" )
      print( f"--- cluster_key: {cluster_key}" )
##      raise ValueError
#      sub_df = sub_df.set_index( cluster_key ).transpose()
##REDO      subfig = px.bar(sub_df, x=sub_df.index,  y=sub_df.columns,
      subfig = px.bar(sub_df, x='meeting',  y='count', 
              color=cluster_key,\
              ##color=d.index.name,\
              # text=d.index.name, 
              title=cluster_key,  
              labels={"count": "Number of Attendees", "meeting": "" } 
      )
      subfig_list.append( subfig )

    suffix = 'distribution'
    if on_site is True:
      title = f"On-Site Attendee Distribution"
    elif on_site is False:
      title = f"Remote Attendee Distribution"
    else:
      title = f"Attendee Distribution" 
    html_file_name = self.image_file_name( suffix, 'html', 'attendee', on_site=on_site,  )
    svg_file_name=self.image_file_name( suffix, 'svg', 'attendee', on_site=on_site )

    fig = co2eq.fig.OneRowSubfig( \
      subfig_list, 
#      subfig_title_list=cluster_key_list,
      fig_title=title,
      print_grid=print_grid,
      show=show,
      shared_xaxes=False,
      shared_yaxes=False,
      legend_offset=[ -0.075, -0.15, -0.225, -0.3, -0.375, -0.45 ],
      fig_height=self.fig_height,
      fig_width=self.fig_width,
      horizontal_spacing=0.15,
      html_file_name=html_file_name, 
      svg_file_name=svg_file_name )
#    fig.fig.show()


##  def plot_attendee_distribution_old( self, debug=True ): 
##    """plots the distribution of the attendees 
##
##    We use the stacked histogram to represent the distribution 
##    according to the various cluster_key values. For example if 
##    cluster_key is 'country', the stacked histogram will 
##    represent the number of attendees per country. 
##
##    The total number of attendees will remain the same. We use 
##    the SVG / HTML representation in order to be able to point 
##    each stack and determine the exact number associated when
##    the mouse points to the stack.  
##    The total number of attendees is the same, so the dimension 
##    of the histogram are the same, and only the way these 
##    histograms (bars) are slacked is changing.
##
##    """
##
##    subfig_list = []
##    for cluster_key in self.cluster_key_list :
##      print( f" --- plot_attendee_distribution -- {cluster_key}" )
##      if cluster_key == 'co2eq' :
##        continue
##      ## d is expected to have the following format  
##      ##  --- : d: <class 'pandas.core.series.Series'>
##      ## country
##      ## KG    1
##      ## IN    1
##      ## MX    1
##      ## CZ    1
##      ## MO    1
##      ## DZ    1
##      ## Name: country, dtype: int64
##      ## d.name: country
##      ## d.index: Index(['KG', 'IN', 'MX', 'CZ', 'MO', 'DZ'], dtype='object', name='country')
##      ## d.index.name: country
##      ## d.index.values: ['KG' 'IN' 'MX' 'CZ' 'MO' 'DZ']
###      d = self.build_data( mode='attendee', cluster_key=cluster_key )
##      d = self.build_data( mode='attendee' )
##      d = d.groupby( by=[ cluster_key ], sort=False )[ cluster_key ].count()
##
##      if debug is True:
##        print( f"--- : d: {type(d)}" )
##        print( d )
##        print( f"d.name: {d.name}" )
##        print( f"d.index: {d.index}" )
##        print( f"d.index.name: {d.index.name}" )
##        print( f"d.index.values: {d.index.values}" )
##
##      ## df is expected to have the following format:
##      ## --- : df: 
##      ## country  KG  IN  MX  CZ  MO  DZ
##      ## country   1   1   1   1   1   1
##      ## 
##      ## df.head: <bound method NDFrame.head of country  KG  IN  MX  CZ  MO  DZ
##      ## country   1   1   1   1   1   1>
##      ## df.columns: Index(['KG', 'IN', 'MX', 'CZ', 'MO', 'DZ'], dtype='object', name='country')
##      ## df.columns.name: country
##      ## df.columns.values: ['KG' 'IN' 'MX' 'CZ' 'MO' 'DZ']
##      ## df.index: Index(['country'], dtype='object')
##
##      df = pd.DataFrame( [ d ] )
##      df.columns.name = cluster_key
##      if debug is True:
##        print( f"--- : df: " )
##        print( df )
##        print( f"\ndf.head: {df.head}" )
##        print( f"df.columns: {df.columns}" )
##        print( f"df.columns.name: {df.columns.name}" )
##        print( f"df.columns.values: {df.columns.values}" )
##        print( f"df.index: {df.index}" )
##      subfig_list.append( px.bar(df, x=df.index, y=df.columns ) ) #, \
##                              # color=df.index,\
##    fig = co2eq.fig.OneRowSubfig( \
##      subfig_list, 
##      offset=1.32, 
##      subfig_title_list=self.cluster_key_list,
##      fig_title=f"{self.name} Distributions of Attendees",
##      html_file_name=self.image_file_name( 'distribution', 'html', 'attendee' ), 
##      svg_file_name=self.image_file_name( 'distribution', 'svg', 'attendee' ) )
##    fig.fig.show( )
##    return None

 
  def plot_distribution( self, mode_list=[ 'attendee', 'flight'], cabin_list=[ 'AVERAGE' ] ):

    for mode in mode_list:
      if mode == 'attendee': 
        self.plot_attendee_distribution( on_site=None) 
        if 'presence' in self.cluster_key_list :  
          for on_site in [ True, False ]:
            self.plot_attendee_distribution( on_site=on_site) 
      elif mode in [ 'flight', 'distance' ]:
        for cabin in cabin_list :  
          self.plot_co2eq_distribution( mode, cabin, on_site=None )
          if 'presence' in self.cluster_key_list:  
            for on_site in [ True, False ]:
              self.plot_co2eq_distribution( mode, cabin, on_site=on_site )
   

  def co2_info_txt( self ):

      
    md = f"""The estimation of the CO2eq emitted by {self.name} is estimated according to a 'mode' and a 'cabin' class. 

The 'mode' can be set to 'flight' or 'distance'. The 'flight' mode uses real flights segments to estimate the CO2eq emitted. The 'flight' mode is always prefered as it takes into consideration multiple takes off and landings as well as flying distance that is non optimal compared to a direct flight. The 'distance' mode on the other end considers only a direct flight. 

The 'cabin' can be set to 'ECONOMY' for economy class, 'BUSINESS' for business class as well as 'AVERAGE' that considers a mixed of 20% of travelers in business and the remaining in economy.

The CO2eq is estimated using various methodology. I this report the following methodologies are used:\n"""
    for co2eq in self.co2eq_method_list:
      if co2eq == 'myclimate':
        txt = ""
      elif co2eq == 'goclimate':
        txt = ""
      elif co2eq == 'ukgov':
        txt = ""
      md+= f"  * {co2eq}: {txt}\n"   
      
    md += "\n\n"

    for mode_cabin in self.info.keys():
      md += f"For the mode '{mode_cabin[0]}' and cabin '{mode_cabin[1]}' the estimations are as follows:\n\n"
      for part in self.info[ mode_cabin ].keys(): #['total', 'on_site', 'remote' ]
        if part == 'total':
          md += f"1. Total Attendees: This means that ALL attendees are considered as attending the Meeting On Site.\n\n" 
        elif part == 'on_site':
          md += f"2. On Site Attendees: This means only the attendees that are effectively marked as attending the meeting On Site.\n\n"
        elif part == 'remote':
          md += f"3. Remote Attendees: This means only the attendees that are attending remotely. This can be interpreted as an kind of Offset. However such interpretation needs to be cautiously considered as it is only valid if emissions associated to a remote participation remains negligible. In general this needs further studies. We also do not consider the attendees that are 'not_arrived' - these are ignored as we expect them to be negligible and neither 'remote' nor 'on-site'.\n\n" 
        else:
          raise ValueError( f"Unknown part {part}. Expecting ['total', 'on_site', 'remote' ]" )
        print( f"info: {self.info}" )
        v = self.info[ mode_cabin ][ part ]    
        md += f"    * Map Distance: {v[ 'map_distance' ]} Km. This represents the total distance between the origin and the destination. The destination is the meeting's destination and the origin destination corresponds to the capital (or most important city in the country) of the country of origin\n"
        md += f"    * Number of Attendees: {v[ 'attendee_nbr' ]}\n"

        md += f"    * Estimation CO2eq :\n"
        for co2eq in self.co2eq_method_list:
          md += f"       * {co2eq} CO2eq: {self.kg( v[ 'co2eq' ][ co2eq ])}\n"
        md += f"       * Average CO2eq: {self.kg( v[ 'co2eq' ][ 'average' ])}. The average CO2eq among {self.co2eq_method_list}.\n"
        md += f"       * Standard Deviation of CO2eq: {v[ 'co2eq' ][ 'stdev' ]}.\n"
        md += f"       * Minimum CO2eq: {self.kg( v[ 'co2eq' ][ 'min' ])}.\n"
        md += f"       * Maximum CO2eq: {self.kg( v[ 'co2eq' ][ 'max' ])}.\n"
        md += f"       * Average CO2eq per Passenger per Km: {self.kg( v[ 'co2eq' ][ 'epppkm' ])}. This considers the Map Distance and the Average CO2eq.\n"


    return md 

  def dist_md( self, mode_list=[ 'flight' , 'attendee' ], 
          cabin_list=[ 'AVERAGE' ], 
          on_site_list=[ None, True, False], 
          banner="",
          toc=True, output_md="index.md" ):
 
    if toc is True:
      toc_md = "\n\n* TOC\n{:toc}\n\n"
    else:
      toc_md = ""

##    md_txt =f"# {self.name} Data \n{banner}\n{toc_md}"

    co2eq_dist = 'flight' in mode_list or 'distance' in mode_list
    atten_dist = 'attendee' in mode_list
    if atten_dist and co2eq_dist :
      title = f"{self.name}: Distribution of CO2 Emission and Attendees"   
      txt = f"This page estimates the CO2 emitted for {self.name} as well as the distribution of the attendees of {self.name}."
    elif atten_dist and not co2eq_dist: 
      title = f"{self.name}: Attendee Distribution"   
      txt = f"This page displays the distribution of the attendees of {self.name}."
    elif not atten_dist and co2eq_dist :
      title = f"{self.name}: Distribution of CO2 Emission"   
      txt = f"This page estimates the CO2 emitted according for {self.name}."
    else: 
      raise ValueError( f"only ")

    md_txt =f"# {title} \n\n{banner}\n\n{toc_md}\n\n{txt}\n\n"
   
    
    txt += self.co2_info_txt( ) 
    if txt is not None:
      md_txt += "## CO2 General Information\n\n"    
      md_txt += f"{txt}\n\n"

    # mode (section)      | grouped for section
    ## cabin (subsection) |
    ### cluster_key (subsubsection)      | combined in one picture
    #### co2eq_method (subsubsubsection) |
####    section_no = 1
####    subsection_no = 1
    print( f"mode_list: {mode_list}" )
    for mode in mode_list:  
      if mode in [ 'flight', 'distance' ]:
        for cabin in cabin_list :
####          section_title = f"CO2 Estimation for '{mode}' mode in cabin {cabin} for {self.name}"
####          section_no_str = roman.toRoman( section_no )
####          md += f"## {section_no_str} {section_title}\n\n"
####          md += f"## {section_title}\n\n"
          md_txt += f"## CO2 Estimation for '{mode}' mode in cabin {cabin} for {self.name}\n\n"
          md_txt += self.md_subsection_txt( mode, on_site_list, cabin )#,\
####                  section_no=section_no_str )
####          section_no += 1
          #for on_site in on_site_list:
          #  html_file_name = self.image_file_name( 'distribution', 'html', mode, 
          #          on_site=on_site )
          #  md += f"<iframe src='{html_file_name}'></iframe>\n\n"
##          for on_site in on_site_list:
#            if on_site is None:
#              sub_section_title = "CO2eq Distribution for All Participants"
#            elif on_site is True: 
#              sub_section_title = "CO2eq Distribution for On-site Participants"
#            elif on_site is False:
#              sub_section_title = "CO2eq Distribution for Remote Participants"
#          md += f"### { roman.toRoman( section_no ) }.{subsection_no} {sub_section_title}\n\n"
#          subsection_no += 1
##            html_file_name = self.image_file_name( 'distribution', 'html', mode, 
##                  cabin=cabin, on_site=on_site )
##          md += f"<iframe src='{html_file_name}'></iframe>\n\n"
      elif mode == 'attendee':
####        section_title = f"Attendee Distribution for {self.name}"
####        section_no_str = roman.toRoman( section_no )
####        md += f"## {section_no_str}. {section_title}\n\n"
####        md += f"## {section_title}\n\n"
        md_txt += f"## Attendee Distribution for {self.name}\n\n"
        md_txt += self.md_subsection_txt( mode, on_site_list ) #, section_no=section_no_str)
###        section_no += 1
#        for on_site in on_site_list:
#          html_file_name = self.image_file_name( 'distribution', 'html', mode, 
#                  on_site=on_site )
#          md += f"<iframe src='{html_file_name}'></iframe>\n\n"
    
####    with open( join( self.output_dir, output_md), 'wt', encoding='utf8' ) as f:
####      f.write( md )
    
    md = co2eq.md.MdFile( md_txt )
    md.number_sections()
    md.save( join( self.output_dir, output_md ) )


####  def embed_html( self, html):
####      return f"<p><embed src='{html}' height={self.fig_height} width={self.fig_width}/></p>\n\n"
      
  def md_subsection_txt( self, mode, on_site_list, cabin=None ): #, section_no=None):
    ## html_file name
#    if mode in [ 'flight', 'distance' ]:
#      html_file_name = self.image_file_name( 'distribution', 'html', mode, 
#            on_site=on_site, cabin=cabin, no_path=True )
#    elif: mode == 'attendee' :
#      html_file_name = self.image_file_name( 'distribution', 'html', mode, 
#            on_site=on_site, no_path=True )
#    else:
#      raise ValueError( f"Unknown mode {mode}. Expecting 'attendee', 'distance' or 'flight'" )

    ## in this class any figure contains all cluster keys
    md = ""  
    for on_site in on_site_list:
      html_file_name = self.image_file_name( 'distribution', 'html', mode, 
          on_site=on_site, cabin=cabin, no_path=True )
#      md +=  f"<iframe src='./{html_file_name}'></iframe>\n\n"
      md +=  self.embed_html( f"./{html_file_name}" )
    return md

## x= companies, y=CO2eq [methods], 
## x= companies, y=CO2eq [methods] / remote[Co2], 


