import os
from os import listdir
from os.path import join, isfile, isdir
import json
import gzip 
import statistics
from datetime import datetime, timedelta
import pandas as pd
pd.options.plotting.backend = "plotly"
import matplotlib
import plotly.express as px
import matplotlib.pyplot as plt
import kaleido ## to be able to export

import requests
from math import ceil
import time 

from co2eq.flight_utils import AirportDB, CityDB, FlightDB, GoClimateDB, CountryDB, Flight, logger, MyClimate
import co2eq.conf
import co2eq.fig
    
class Meeting:

  def __init__( self, name:str, 
                location:dict, 
                attendee_list:str = None, \
                base_output_dir=None, 
                conf=co2eq.conf.Conf().CONF,  \
                airportDB=True, 
                cityDB=True, 
                flightDB=True, 
                goclimateDB=True ):
    """ Meeting class

    Since conf is used to generate some DB (goclimateDB), DB can either
    be provided as object of set to True to indicate these need to be generated.

    Args:
      name (str): the name of the meeting
      location (dict): a location structure where the meeting is happening
        The dictionnary take sthe foillowing form: 
            {
               "country": "CZ",
               "city": "Prague"
             }
      attendee_list (str or lst): It is expected to be the path of a JSON file 
        that contains the attendee list. By default an attendee is a dictionary 
        structure which at least contains:
           { 
              "country" : "Country Code" 
           } 
        Attendee may also include additional information sur as :
           {
              "country": "KG",
              "organization": "association of communications operators",
              "presence": "on-site"
            },
      base_output_dir (str): the directory where all data and figures are put.
      conf (dict): configuration parameters
      airportDB: the airportDB object ( AirportDB ) or True to indicate the DB
        is generated by FlightDB.
        By default it is set to True.
      cityDB: the cityDB object ( CityDB ) or True to indicate the DB is
        generated by FlightDB.
        By default it is set to True.
      goclimateDB: the cityDB object ( GoClimateDB ) or True to indicate the DB
        is generated by FlightDB.
        By default it is set to True. Note that this is the only DB that needs
        the configuration parameters.

    """
    self.name = name
    self.conf = conf
    print( f"Computing CO2eq for {self.name}\n" )
    print( f"Configuration:\n {self.conf}" )
    if airportDB is True:
      self.airportDB = AirportDB()
    else:
      self.airportDB = airportDB
    if  cityDB is True:
      self.cityDB = CityDB( conf, airportDB=self.airportDB )
    else:
      self.cityDB = cityDB
    if goclimateDB is True:
      self.goclimateDB=GoClimateDB( conf )
    else:
      self.goclimateDB = goclimateDB
    ## flightDB and designate it by the destination airport
    if flightDB is True:
      flightDB = FlightDB( conf, cityDB=self.cityDB, airportDB=self.airportDB, \
                           goclimateDB=self.goclimateDB)
    self.flightDB = flightDB

    self.countryDB = CountryDB()
    # print( f"meeting iata location: {self.iata_location}" )
    if base_output_dir is None:
      base_output_dir = './output'
    self.output_dir = join( base_output_dir, self.name )

    ## location is a dictionary with keys iata, city, state, country)
    self.location = location
    self.meeting_iata_city = self.cityDB.representative_city( self.location )[ 'iata' ]

    if isdir( self.output_dir ) is False:
      os.makedirs( self.output_dir )
    self.logger = logger( conf, __name__ )

    self.attendee_list = attendee_list
    df = pd.read_json( attendee_list )
    ## to build flightDB
    self.country_list = df[ 'country' ].unique().tolist()
 #   self.total_attendee_nbr = len( df )
    self.cluster_key_list = list( df )
    self.cluster_key_list.extend( ['segment_nbr', 'subregion', 'region', 'co2eq' ] )
    ## ensure 'presence' is in the first position 
    if 'presence' in self.cluster_key_list:
      self.cluster_key_list.remove( 'presence' )
      self.cluster_key_list.insert( 0, 'presence' )
    self.co2eq_method_list = [ 'myclimate', 'goclimate', 'ukgov' ]

    ## DataFrame
    self.df_data = {}
    self.info = {}
    ### built variables
    ##    self.total_attendee_nbr = None
    ## total_map distance to represent the effectice 
    ## traveled distance between the two end points.
    ## this is different from the flying distance.
#    self.total_map_distance = None
    ## self.total_co2eq = { ( mode, cabin, co2eq_method ) : co2eq_value }
#    self.total_co2eq = {}
#    self.cluster_key_list = [] # list( self.df_attendee_list )
    # self.cluster_key_list.extend( ['segment_nbr', 'subregion', 'region', 'co2eq' ] )
#    self.co2eq_method_list = [] #[ 'myclimate', 'goclimate', 'ukgov' ]

    ## data base of all flight information associated to the 
    ## meeting self.flight_db[ ( mode, cabin ) ] [ country ] = flight
    self.flight_db = {}
##   self.km = None

  
  def get_attendee_flight( self, country, cabin ):
    """ returns the flight associated to the attendee for a specific cabin 

    Args: 
      attendee (dict): a structure representing the attendee
      cabin (str) : an indication of the cabin. While the same 
        plane may carry various class, it will afect the CO2eq,
        price, as well as possibly some cabin class will not be
        available in some journeys. As aresult, we choose to 
        associate the cabin to teh flight.
        Note that co2eq is computed for the various known metrics 

    Returns:
      flight (dict) :  a structure that looks like 
        {
          'origin' : self.origin,
          'destination' : self.destination,
          'departure_date' : self.departure_date,
          'return_date' : self.return_date,
          'cabin' : self.cabin,
          'adults' : self.adults,
          'segment_list' : self.segment_list,
          'price' : self.price,
          'currency' : self.currency,
          'travel_duration' : str( self.travel_duration ),
          'flight_duration' : str( self.flight_duration ),
          'flying_distance' : str( self.flying_distance ),
          'map_distance' : str( self.flying_distance ),
          'co2eq' : { 'myclimate' : co2eq,  
                      'ukgov' :     co2eq, 
                      'goclimate' : co2eq } }

    """
    ## object that corresponds to a no-flight
    NULL_FLIGHT = {
      'origin' : self.meeting_iata_city,
      'destination' : self.meeting_iata_city,
#      'departure_date' : self.departure_date,
#      'return_date' : self.return_date,
      'cabin' : cabin,
      'adults' : 1,
      'segment_list' : [],
      'price' : 0,
      'currency' : 'USD',
      'travel_duration' : str( 0 ),
      'flight_duration' : str( 0 ),
      'flying_distance' : 0,
      'map_distance' : 0,
      'co2eq' : { 'myclimate' : 0,  
                  'ukgov' :     0, 
                  'goclimate' : 0 } }

    ## only the country is considered
    ## the country represents the country 
    ## of origin of the attendee
    loc = { "country" : country}

    attendee_iata_city = self.cityDB.representative_city( loc )[ 'iata' ]
    self.logger.debug( f"  - Flight from {attendee_iata_city} to  {self.meeting_iata_city}" )
    if attendee_iata_city == self.meeting_iata_city :
      return NULL_FLIGHT
    if attendee_iata_city in [ '', None ]:
      self.logger.debug( "Unable to find city for {attendee}" )
    try:
      return self.flightDB.force_select_flight( attendee_iata_city , self.meeting_iata_city  )
    except :
#      if 'country' in attendee.keys() and 'city' not in attendee.keys() and 'state' not in attendee.keys() :
      print( f"\n-----------------------------\n"\
             f"Unable to retrieve flight: FROM: {attendee_iata_city} "\
             f"TO: {self.meeting_iata_city}\n" )
      self.debug_country_info( attendee[ 'country' ] )
      raise ValueError( "unable top retrieve flight")

 
  def get_attendee_flight_obj( self, country,  cabin, mode ):
    """ returns the flight object used to compute co2eq and distance 

    This function primarily sets a speudo flight in a distance mode 
    which corresponds to a direct flight.
    """

    ## 'distance' mode requires a specific computation 
    if mode == 'distance' :
      loc = { "country" : country}
      attendee_iata_city = self.cityDB.representative_city( loc )[ 'iata' ]
      # meeting_iata_city = self.cityDB.representative_city( self.location )[ 'iata' ]
      self.logger.debug( f"  - Flight from {attendee_iata_city} to  {self.meeting_iata_city}" )
      segment_list = [ [ attendee_iata_city , self.meeting_iata_city  ],  \
                       [ attendee_iata_city , self.meeting_iata_city  ] ]
      flight = { 'segment_list' : [ [ attendee_iata_city , self.meeting_iata_city  ],  \
                                    [ attendee_iata_city , self.meeting_iata_city  ] ], 
                 'cabin' : cabin, 
                 'co2eq' : None } ## forcing co2eq computation
    else: 
      flight = self.get_attendee_flight( country, cabin )
    ## forcing co2eq computation  
    flight = Flight( **flight, cityDB=self.cityDB, \
                     airportDB=self.airportDB, goclimateDB=self.goclimateDB)
    flight = flight.export()
    return flight
      
 
  def build_flight_db( self, mode, cabin ):
    """ compute and retrieve the flight object for mode and cabin

    One the flight objects are prefetched is to prevent repeating the 
    requests to the larger FlightDB.
    Repeated request occurs when diferent co2eq methods are performed 
    as well as when multiple users are coming from the same country

    The database self.db is as represented below:
    { (mode, cabin) :
      { country_code : 
        { 'co2eq_method' : 
          { 'goclimate' : gocliamte_value,
            'myclimate' : myclimate_value,
            'uk_gov' : uk_gov_value }  
          'segment_list' : 3 },
        country_code :     
        { 'co2eq_method' : 
          { 'goclimate' : gocliamte_value,
            ... }
      },
      (mode, cabin) :
      { country_code : 
      ...
      },
    }  
    """
    if ( mode, cabin ) in self.flight_db.keys():
      return None
    self.flight_db[ ( mode, cabin ) ] = {}    
#    country_list = self.df_attendee_list[ 'country' ].unique().tolist()
    t_start = time.time()
    for country in self.country_list :
      flight = self.get_attendee_flight_obj( country,  cabin, mode ) 
      if not isinstance( flight, dict ): 
        raise ValueError( f"unexpected flight object for "\
                f"{( country,  cabin, mode )}: {flight}" )
      self.flight_db[ ( mode, cabin ) ] [ country ] = flight
    t_stop = time.time()
    print( f"Building flight_db in {t_stop - t_start} sec" )
    print( f"resolution time: {( t_stop - t_start ) / len( self.country_list ) } sec")



  ## the following functions are helpers to complete the dataframe
  def get_attendee_co2eq( self, mode, cabin, country, co2eq_method ):
    return self.flight_db[ ( mode, cabin ) ][ country ][ 'co2eq'][ co2eq_method ]
    
  def get_attendee_seg_nbr( self, mode, cabin, country ):
    if mode == 'attendee' :
      mode = 'flight'
    return len( self.flight_db[ ( mode, cabin ) ][ country ][ 'segment_list' ] )
#    return len( self.flight_db[ mode ][ cabin ][ country ][ 'segment_list' ] )

  def get_attendee_subregion( self, country ):
    return self.countryDB.get_country_info( country ).subregion()

  def get_attendee_region( self, country ):
    return self.countryDB.get_country_info( country ).region()

  def get_attendee_map_distance( self, mode, cabin, country ):
    """
    
    We provide mode and cabin to make sure the corresponding flight have 
    "previously" been computed, but the distance does not depends on mode
    and cabin.
    """
    return self.flight_db[ ( mode, cabin ) ][ country ][ 'map_distance' ]


  def kwargs_to_str( self, **kwargs:dict ) -> str:
    """ build a file name string from kwargs """
    file_name = ""
    for key, value in kwargs.items():
      file_name += f"{key}-{value}--"
    return file_name[ :-2 ] 

  def str_to_kwargs( self, file_name ): 
    """ retrieves kwargs from a file name 

    This is the reverse function of kwargs_to_file_name. 

    Args:
      file_name (str): the file name

    Returns:
      arg_dict (dict): the various characteristics of the file
        { 'mode' : mode,
          'cluster_key' : cluster_key,
          'co2eq' : co2eq,
          'cabin' : cabin }
    """
    
    if file_name[ -4: ] in [ '.svg', '.json' ] :
      file_name = file_name[: -4 ]   
    kw = {}  
    for seg in file_name.split('--'):
      split_seg = seg.split( '-' )
      kw[ split_seg[ 0 ] ] = split_seg[ 1 ]
    return kw

  def json_file_name( self, name, mode, cluster_key=None, co2eq_method=None, cabin=None ):
    if mode == 'attendee' : 
      if co2eq_method is not None and cabin is not None :
        raise ValueError( f"with mode 'attendee', co2eq_method"\
                f" and cabin MUST be None. Got {locals()}" ) 
    f_kwargs = { } 
##    print( locals() )
    for k in list( locals().keys() ):
      if k in [ 'self', 'ext', 'f_kwargs' ]:
        continue
      if locals()[ k ] is not None:
        f_kwargs[ k] = locals()[ k ]
    data_file = self.kwargs_to_str( **f_kwargs )
    return os.path.join( self.output_dir, data_file + ".json")

# data_file = self.kwargs_to_str( name=name, mode=mode, cluster_key=cluster_key )
#    else: 
#      data_file = self.kwargs_to_str( name=name, mode=mode, cluster_key=cluster_key,\
#        co2eq_method=co2eq_method, cabin=cabin)
#    return os.path.join( self.output_dir, data_file + ".json")

  def image_file_name( self, name, ext, mode, cabin=None, cluster_key=None, co2eq_method=None ):
    """ return an image file name
   
    The intent is to ensure a certain format in the file names, as
    well as to perform some minor checks and avoid duplictaed files
    with different names. 
    """
    if mode == 'attendee' and ( cabin is not None or co2eq_method is not None ):
      raise ValueError( f"with mode 'attendee'  cabin and co2eq_method"\
              "are expected to be set to None. Got {locals()}." )
    f_kwargs = { } 
##    print( locals() )
    for k in list( locals().keys() ):
      if k in [ 'self', 'ext', 'f_kwargs' ]:
        continue
      if locals()[ k ] is not None:
        f_kwargs[ k] = locals()[ k ]
    data_file = self.kwargs_to_str( **f_kwargs )
    return os.path.join( self.output_dir, data_file + "." + ext )



  def df_to_co2eq_info( self, df ):
    print( "--- df" )
    print( df.info )
    map_distance = df[ "map_distance" ].sum() 
    attendee_nbr  = len( df )
    co2eq = {}
    for co2eq_method in self.co2eq_method_list :
      co2eq[ co2eq_method ] = df[ co2eq_method ].sum()    
    co2eq_list = co2eq.values()
#    for m in self.co2eq_method_list:
#      co2eq_list.append( self.co2eq[ ( mode, cabin, m ) ] )
    co2eq[ 'average' ] = statistics.mean( co2eq_list )
    co2eq[ 'stdev' ] = statistics.stdev( co2eq_list ) 
    co2eq[ 'min' ]  = min ( co2eq_list)
    co2eq[ 'max' ]  = max( co2eq_list )
#    print( f"total_map_distance : {self.total_map_distance}" )
#    print( f"total_attendee_nbr: {self.total_attendee_nbr}" )
    co2eq[ 'epppkm' ] = co2eq[ 'average' ] / map_distance / attendee_nbr
#    title = f"{self.name} Distribution of CO2eq emissions for {mode} mode, cabin {cabin} "\
#            f"- {self.info[ 'total_attendee_nbr' ]} attendees<br>"\
#            f"   - Co2eq -- mean: {self.kg( self.info[ 'total_co2eq' ][ 'average' ] )}, "\
#            f"min: {self.kg( self.info[ 'totalm )}, max: {self.kg( M )}, std: {self.kg( stdev )}<br>"\
#            f"   - Co2eq per passenger Km: {self.kg( epppkm )}/p/km <br>"\
    return { 'map_distance' : map_distance, 
             'attendee_nbr' : attendee_nbr,
             'co2eq' : co2eq }



  def build_data( self, mode='flight', cabin=None ) -> dict :
    """ co2 equivalent based on real flights including multiple segments)

    The possible modes are 'attendee', 'flight', 'distance'. 
    'flight' and 'distance' always output a number of CO2eq in kg
    'attendee' always outputs a number of attendees
    cluster_key can be any key mention in the participant object or 
    take special values like 'segmentNbr'.

    Todo:
      * we are doing now a lot of measurements and each time we retrieves
        the flights. We need to be able to comput ea attendee_flight_list once. 
    """
    ## return the df in cache is present
    if ( mode, cabin )  in self.df_data.keys():
      return self.df_data[ ( mode, cabin ) ]

    ## read from json if already computed
    ## commenting to force the generation of the pd
    if mode == 'attendee':
      data_file = self.json_file_name( 'data', mode )
      cluster_key_list = self.cluster_key_list[:]
      cluster_key_list.remove( 'co2eq' )
      cabin = None 
    else: 
      if cabin is None: 
        cabin = 'AVERAGE'
      data_file = self.json_file_name( 'data', mode, cabin=cabin ) 

    if data_file is True: 
      self.df_data[ ( mode, cabin ) ] =  pd.read_json( data_file )
      return self.df_data[ ( mode, cabin ) ]

    ## building the data 
    df = pd.read_json( self.attendee_list )

    ## 1. preparing flights information
    if mode in [ 'flight', 'distance' ] :
      self.build_flight_db( mode, cabin )
    elif mode == 'attendee' : # needed for 'segment_nbr'
      self.build_flight_db( 'flight', 'AVERAGE' )
    
    ## 2.a. Filling all values associated to cluster_key 
    for cluster_key in self.cluster_key_list :
      if cluster_key == 'segment_nbr' :
        if mode == 'attendee' :
          ## to compute segment numbers, we use the cabin set to AVERAGE   
          df[ 'segment_nbr' ] = df.apply( lambda x: self.get_attendee_seg_nbr( mode, 'AVERAGE', x['country'] ), axis=1)
        else: 
          df[ 'segment_nbr' ] = df.apply( lambda x: self.get_attendee_seg_nbr( mode, cabin, x['country'] ), axis=1)

      elif cluster_key == 'subregion' :
        df[ 'subregion' ] = df.apply( lambda x: self.get_attendee_subregion( x['country'] ), axis=1 )
      elif cluster_key == 'region' :
        df[ 'region' ] = df.apply( lambda x: self.get_attendee_region( x['country'] ), axis=1 )
      elif cluster_key == 'co2eq' : 
        if mode not in [ 'flight', 'distance' ] or self.co2eq_method_list == []:
          continue
        for co2eq_method in self.co2eq_method_list: 
          df[ co2eq_method ] = df.apply( lambda x: self.get_attendee_co2eq( mode, cabin, x['country'], co2eq_method) , axis=1)
#          ## computing total_co2eq
#          k = ( mode, cabin, co2eq_method )
#          if k not in self.total_co2eq.keys() :
#            self.total_co2eq[ k ]  = df[ co2eq_method ].sum()
        ## we ensure total_map_distance is computed.
        if 'total_map_distance' not in self.info.keys() :
          df[ "map_distance" ] = df.apply( lambda x: self.get_attendee_map_distance( mode, cabin, x[ 'country' ] ) , axis=1)
#          self.total_map_distance = df[ "map_distance" ].sum()

    df.to_json( data_file )
    self.df_data[ ( mode, cabin ) ] =  df
    
    ## building information
##    map_distance = df[ "map_distance" ].sum() 
##    attendee_nbr  = len( df )
##    total_co2eq = {}
##    for m in self.co2eq_method_list :
##      total_co2eq[ co2eq_method ] = df[ co2eq_method ].sum()    
##    total_co2eq_list = total_co2eq.values()
###    for m in self.co2eq_method_list:
###      co2eq_list.append( self.total_co2eq[ ( mode, cabin, m ) ] )
##    total_co2eq[ 'average' ] = statistics.mean( total_co2eq_list )
##    total_co2eq[ 'stdev' ] = statistics.stdev( total_co2eq_list ) 
##    total_co2eq[ 'min' ]  = min ( total_co2eq_list)
##    total_co2eq[ 'max' ]  = max( total_co2eq_list )
###    print( f"total_map_distance : {self.total_map_distance}" )
###    print( f"total_attendee_nbr: {self.total_attendee_nbr}" )
##    total_co2eq[ 'epppkm' ] = total_co2eq[ 'average' ] / self.info[ 'total_map_distance' ] / self.info[ 'total_attendee_nbr' ] 
###    title = f"{self.name} Distribution of CO2eq emissions for {mode} mode, cabin {cabin} "\
###            f"- {self.info[ 'total_attendee_nbr' ]} attendees<br>"\
###            f"   - Co2eq -- mean: {self.kg( self.info[ 'total_co2eq' ][ 'average' ] )}, "\
###            f"min: {self.kg( self.info[ 'totalm )}, max: {self.kg( M )}, std: {self.kg( stdev )}<br>"\
###            f"   - Co2eq per passenger Km: {self.kg( epppkm )}/p/km <br>"\
##    self.info[ ( mode, cabin ) ] = { 'total' : { 'map_distance' : map_distance, 
##                                                 'attendee_nbr' : attendee_nbr,
##                                                 'co2eq' : total_co2eq }
    if mode in [ 'flight', 'distance' ]:
      self.info[ ( mode, cabin ) ] = { 'total' : self.df_to_co2eq_info( df ) } 
      if 'presence' in self.cluster_key_list :
        self.info[ ( mode, cabin ) ][ 'on_site' ] = self.df_to_co2eq_info( df[ df.presence == 'on-site' ] )
        self.info[ ( mode, cabin ) ][ 'non_on_site' ] = self.df_to_co2eq_info( df[ df.presence != 'on-site' ] )

    return df


##    ## Extraction of the data should be performed in each function.  
##    ## 3. extracting the data to be plot        
##    if mode == 'attendee':
##      ## group by country, take the 'country' colum  and count elements
##      df = self.df_attendee_list.groupby( by=[ cluster_key ], sort=False )[ cluster_key ].count()
##    elif mode in [ 'flight', 'distance' ]:
##      df = self.df_attendee_list.groupby( by=[ cluster_key ], sort=False )[ co2eq_method ].sum()
###      df = self.df_attendee_list.groupby( by=[ f"co2eq-{co2eq_method}", cluster_key ], sort=False ).sum().unstack()
##
##    df.to_json( data_file )
##    return df
    
###plot:
###    basic stacked histogram:
###        https://plotly.com/python/bar-charts/#bar-chart-with-hover-text
###    interactive versus html
###        https://plotly.com/python/interactive-html-export/#interactive-vs-static-export
###        https://plotly.com/python/static-image-export/
###    Dropdown Menus in Python (to consider modes, cluster_key, co2eq method)
###        https://plotly.com/python/dropdowns/

### using the backend 
### https://plotly.com/python/pandas-backend/
### https://www.shanelynn.ie/bar-plots-in-python-using-pandas-dataframes/

  

  def plot_co2eq_distribution( self, mode, cabin, on_site=True):
    """ plots the distribution of CO2eq according to cluster_key

    CO2eq distribution is plot against each cluster_key (presence,
    country, subregion, region, ...).  
    
    When 'presence' is provided as a cluster_key two kinds of
    graphs are generated:
      - 1. a CO2eq distribution for EFFECTIVE CO2 emissions that
        is associated to participants that are 'on-ste'
      - 2. a CO2eq distribution for participants that are not 
        'on-site'. This represents a sort of OFFSET.
    
    Note that for both 1. and 2. the CO2eq distribution between 
    'on-site' and non 'on-site' participant is provided.

    """
    df = self.build_data( mode=mode, cabin=cabin )

    ## check 'co2eq is a cluster_key and if so handle it properly, 
    ## that is considering all other cluster_keys.
    cluster_key_list = self.cluster_key_list[ : ]
    cluster_key_list.remove( 'co2eq' )
    
    ## https://plotly.com/python/wide-form/
    ## https://keytodatascience.com/groupby-pandas-python
    subfig_list = []

    ## defining how aggregation is performed. In our case
    ## aggregation is performed simultaneously for every 
    ## co2eq_methods
    agg_dict = {}
    for co2eq_method in self.co2eq_method_list :
      agg_dict[ co2eq_method ] = 'sum'

    for cluster_key in cluster_key_list :
      ## with cluster_key set to presence, we plot the CO2eq 
      ## associated to the presence, which includes remote,
      ## not arrived and on-site
      if cluster_key in [ 'presence' ] :
        sub_df = df.groupby( by=[ cluster_key, ], sort=False ).agg( agg_dict ).reset_index()
      ## for other cluster_key we only focus on the CO2 associated to 
      ## on-site participants'
      else:
        if 'presence' in df.columns :
          if on_site is True:   
            sub_df = df[ df.presence == 'on-site' ].groupby( by=[ cluster_key, ], sort=False ).agg( agg_dict ).reset_index()
          else:
            sub_df = df[ df.presence != 'on-site' ].groupby( by=[ cluster_key, ], sort=False ).agg( agg_dict ).reset_index()
        else:
          sub_df = df.groupby( by=[ cluster_key, ], sort=False ).agg( agg_dict ).reset_index()

      sub_df = sub_df.set_index( cluster_key ).transpose()

      subfig = px.bar(sub_df, x=sub_df.index,  y=sub_df.columns, 
              ##color=d.index.name,\
              # text=d.index.name, 
              title=cluster_key,  
              labels={"co2eq": "CO2eq (Kg)", "co2eq": "CO2eq Estimation Method" } )
      subfig_list.append( subfig )


    if 'presence' in df.columns :
      if on_site is True:
        suffix = 'distribution-onsite'
        title = f"{self.name} CO2eq Distribution of 'on-site' participants (Effective CO2eq)"
      else:
        suffix = 'distribution-not-onsite'
        title = f"{self.name} CO2eq Distribution of non 'on-site' participants (~Offset CO2eq)"
    else:
        suffix = 'distribution'
        title = "{self.name} CO2eq Distribution" 
    html_file_name = self.image_file_name( suffix, 'html', mode, cabin )
    svg_file_name=self.image_file_name( suffix, 'svg', mode, cabin )

    fig = co2eq.fig.OneRowSubfig( \
      subfig_list, 
      offset=1.32, 
      subfig_title_list=cluster_key_list,
      fig_title=title,
      html_file_name=html_file_name, 
      svg_file_name=svg_file_name )
    fig.fig.show()

  def kg( self, number) :
    """ returns the string associated to number in Kg

    Because Kg is the unit but we want Mg instead of kKg we convert in g 
    """
    engFormat = matplotlib.ticker.EngFormatter(unit='g',places=2,sep='')
    return engFormat( 1000 * number )

  def plot_attendees_distribution( self, on_site=None ): 
    """ 
    args:
      on_site: defines the subset of the attendees. None True False
    """

    ## on_site is only considered when 'presence' is indicated. 
    ## we coudl have set on_site to None, but this might result
    ## in the same graph being re-computed 3 times
    ## (on_site = True/False, None). So we prefer not computing 
    ## the graph when incoherent parameters are provided. 
    if 'presence' not in df.columns and on_site is not None:
      return None

    df = self.build_data( mode=attendee )

    ## check 'co2eq is a cluster_key and if so handle it properly, 
    ## that is considering all other cluster_keys.
    cluster_key_list = self.cluster_key_list[ : ]
    cluster_key_list.remove( 'co2eq' )
    
    ## https://plotly.com/python/wide-form/
    ## https://keytodatascience.com/groupby-pandas-python
    subfig_list = []

#    ## defining how aggregation is performed. In our case
#    ## aggregation is performed simultaneously for every 
#    ## co2eq_methods
#    agg_dict = {}
#    for co2eq_method in self.co2eq_method_list :
#      agg_dict[ co2eq_method ] = 'sum'

    for cluster_key in cluster_key_list :
      ## with cluster_key set to presence, we plot the number
      ## of attendees. 
      ## associated to the presence, which includes remote,
      ## not arrived and on-site
      if cluster_key in [ 'presence' ] :
        sub_df = df.groupby( by=[ cluster_key, ], sort=False ).count().reset_index()
      ## for other cluster_key we only focus on the CO2 associated to 
      ## on-site participants'
      else:
        if on_site is True:   
          sub_df = df[ df.presence == 'on-site' ].groupby( by=[ cluster_key, ], sort=False ).count().reset_index()
        elif on_site is False:
          sub_df = df[ df.presence != 'on-site' ].groupby( by=[ cluster_key, ], sort=False ).count().reset_index()
        elif on_site is None:
          sub_df = df.groupby( by=[ cluster_key, ], sort=False ).count().reset_index()
        else:
          raise ValueError( f"unexpected value for on_site: {on_site}"\
                  f" on_site MUST be in True, False or None." )
      sub_df = sub_df.set_index( cluster_key ).transpose()
      subfig = px.bar(sub_df, x=sub_df.index,  y=sub_df.columns, 
              ##color=d.index.name,\
              # text=d.index.name, 
              title=cluster_key,  
              labels={"co2eq": "CO2eq (Kg)", "co2eq": "CO2eq Estimation Method" } )
      subfig_list.append( subfig )


    if on_site is True:
      suffix = 'distribution-attendees-onsite'
      title = f"{self.name} 'on-site' Attendee Distribution"
    elif on_site is False:
      suffix = 'distribution-attendees-not-onsite'
      title = f"{self.name} non 'on-site' Attendees Distribution"
    else:
      suffix = 'distribution-attendee-all'
      title = "{self.name} Attendee Distribution" 
    html_file_name = self.image_file_name( suffix, 'html', mode, cabin )
    svg_file_name=self.image_file_name( suffix, 'svg', mode, cabin )

    fig = co2eq.fig.OneRowSubfig( \
      subfig_list, 
      offset=1.32, 
      subfig_title_list=cluster_key_list,
      fig_title=title,
      html_file_name=html_file_name, 
      svg_file_name=svg_file_name )
    fig.fig.show()


  def plot_attendees_distribution_old( self, debug=True ): 
    """plots the distribution of the attendees 

    We use the stacked histogram to represent the distribution 
    according to the various cluster_key values. For example if 
    cluster_key is 'country', the stacked histogram will 
    represent the number of attendees per country. 

    The total number of attendees will remain the same. We use 
    the SVG / HTML representation in order to be able to point 
    each stack and determine the exact number associated when
    the mouse points to the stack.  
    The total number of attendees is the same, so the dimension 
    of the histogram are the same, and only the way these 
    histograms (bars) are slacked is changing.

    """

    subfig_list = []
    for cluster_key in self.cluster_key_list :
      print( f" --- plot_attendees_distribution -- {cluster_key}" )
      if cluster_key == 'co2eq' :
        continue
      ## d is expected to have the following format  
      ##  --- : d: <class 'pandas.core.series.Series'>
      ## country
      ## KG    1
      ## IN    1
      ## MX    1
      ## CZ    1
      ## MO    1
      ## DZ    1
      ## Name: country, dtype: int64
      ## d.name: country
      ## d.index: Index(['KG', 'IN', 'MX', 'CZ', 'MO', 'DZ'], dtype='object', name='country')
      ## d.index.name: country
      ## d.index.values: ['KG' 'IN' 'MX' 'CZ' 'MO' 'DZ']
#      d = self.build_data( mode='attendee', cluster_key=cluster_key )
      d = self.build_data( mode='attendee' )
      d = d.groupby( by=[ cluster_key ], sort=False )[ cluster_key ].count()

      if debug is True:
        print( f"--- : d: {type(d)}" )
        print( d )
        print( f"d.name: {d.name}" )
        print( f"d.index: {d.index}" )
        print( f"d.index.name: {d.index.name}" )
        print( f"d.index.values: {d.index.values}" )

      ## df is expected to have the following format:
      ## --- : df: 
      ## country  KG  IN  MX  CZ  MO  DZ
      ## country   1   1   1   1   1   1
      ## 
      ## df.head: <bound method NDFrame.head of country  KG  IN  MX  CZ  MO  DZ
      ## country   1   1   1   1   1   1>
      ## df.columns: Index(['KG', 'IN', 'MX', 'CZ', 'MO', 'DZ'], dtype='object', name='country')
      ## df.columns.name: country
      ## df.columns.values: ['KG' 'IN' 'MX' 'CZ' 'MO' 'DZ']
      ## df.index: Index(['country'], dtype='object')

      df = pd.DataFrame( [ d ] )
      df.columns.name = cluster_key
      if debug is True:
        print( f"--- : df: " )
        print( df )
        print( f"\ndf.head: {df.head}" )
        print( f"df.columns: {df.columns}" )
        print( f"df.columns.name: {df.columns.name}" )
        print( f"df.columns.values: {df.columns.values}" )
        print( f"df.index: {df.index}" )
      subfig_list.append( px.bar(df, x=df.index, y=df.columns ) ) #, \
                              # color=df.index,\
    fig = co2eq.fig.OneRowSubfig( \
      subfig_list, 
      offset=1.32, 
      subfig_title_list=self.cluster_key_list,
      fig_title=f"{self.name} Distributions of Attendees",
      html_file_name=self.image_file_name( 'distribution', 'html', 'attendee' ), 
      svg_file_name=self.image_file_name( 'distribution', 'svg', 'attendee' ) )
    fig.fig.show( )
    return None

 
  def plot_distribution( self, mode_list=[ 'attendee', 'flight'], cabine_list=[ 'AVERAGE' ] ):

    if 'attendee' in mode_list: 
      if 'presence' in self.cluster_key_list :  
        for on_site in [ True, False ]:
          self.plot_attendees_distribution( on_site=on_site) 
      self.plot_attendees_distribution( on_site=None) 

      mode_list.remove( 'attendee' )

    for mode in mode_list:
       for cabin in cabine_list :  
         if 'co2eq' not in self.cluster_key_list :
           continue
         self.plot_co2eq_distribution( mode, cabin, on_site=True )
         if 'presence' in self.cluster_key_list:  
           self.plot_co2eq_distribution( mode, cabin, on_site=False )
   

## x= companies, y=CO2eq [methods], 
## x= companies, y=CO2eq [methods] / remote[Co2], 


